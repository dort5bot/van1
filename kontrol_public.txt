dosyayı incele,
│   │   ├── binance_pb_**.py       # REST public  api endpointlerini  gösterir
│   │   ├── binance_pb_spot.py     # Market Data→ Spot market public
│   │   ├── binance_pb_futures.py  # Futures market public
│   │   ├── binance_pb_system.py   # System→ Exchange Info,Ping, exchangeInfo
│   │   ├── binance_pb_index.py    # Index/mark price

ayrı dosyalar halinde gruplandırılmış public endpointleri var.
eksik endpotler var mı varsa nelerdir,
binance api standartlarına uygun olarak isim değiştirmeden
eklenebilir halde ver
yapıya uygun şekilde ver











# ==== binance_pb_futures.py ====

"""
utils/binance/binance_pb_futures.py
----------------------------------
Futures (public) endpoints wrapper.

- Futures public endpoints (market data) için metodlar içerir.
- Async / aiohttp tabanlı BinanceHTTPClient ile çalışır.
- Singleton pattern, PEP8, type hints, docstrings ve logging içerir.
"""

from __future__ import annotations

import logging
from typing import Any, Dict, List, Optional

from .binance_request import BinanceHTTPClient
from .binance_constants import (
    FUTURES_PING_ENDPOINT,
    FUTURES_TIME_ENDPOINT,
    FUTURES_EXCHANGE_INFO_ENDPOINT,
    FUTURES_ORDER_BOOK_ENDPOINT,
    FUTURES_KLINE_ENDPOINT,
)
from .binance_types import ExchangeInfo, Kline, OrderBook

logger = logging.getLogger(__name__)


class BinancePBFutures:
    """
    Public-Futures (PB) wrapper exposing commonly used futures public endpoints.

    Usage:
        fut = BinancePBFutures.get_instance()
        await fut.ping()
    """

    _instance: Optional["BinancePBFutures"] = None

    def __init__(self, http_client: Optional[BinanceHTTPClient] = None) -> None:
        # futures flag will be passed to underlying HTTP client methods
        self._http = http_client or BinanceHTTPClient()
        logger.debug("BinancePBFutures initialized")

    @classmethod
    def get_instance(cls, http_client: Optional[BinanceHTTPClient] = None) -> "BinancePBFutures":
        """Return singleton instance."""
        if cls._instance is None:
            cls._instance = cls(http_client=http_client)
        elif http_client is not None:
            cls._instance._http = http_client
        return cls._instance

    # -------------------------
    # System / simple helpers
    # -------------------------
    async def ping(self) -> bool:
        """Ping futures endpoint."""
        logger.debug("Futures: ping")
        await self._http.get(FUTURES_PING_ENDPOINT, futures=True)
        return True

    async def server_time(self) -> int:
        """Get futures server time (ms)."""
        logger.debug("Futures: server_time")
        data = await self._http.get(FUTURES_TIME_ENDPOINT, futures=True)
        return int(data.get("serverTime", 0))

    async def exchange_info(self, symbol: Optional[str] = None) -> ExchangeInfo:
        """
        Futures exchange info.
        """
        params = {"symbol": symbol} if symbol else None
        logger.debug("Futures: exchange_info %s", symbol)
        data = await self._http.get(FUTURES_EXCHANGE_INFO_ENDPOINT, params=params, futures=True)
        return data  # type: ignore[return-value]

    # -------------------------
    # Market Data
    # -------------------------
    async def order_book(self, symbol: str, limit: int = 100) -> OrderBook:
        """Get futures order book."""
        params = {"symbol": symbol.upper(), "limit": int(limit)}
        logger.debug("Futures: order_book %s limit=%s", symbol, limit)
        data = await self._http.get(FUTURES_ORDER_BOOK_ENDPOINT, params=params, futures=True)
        return data  # type: ignore[return-value]

    async def klines(
        self,
        symbol: str,
        interval: str,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: int = 500,
    ) -> List[Kline]:
        """Get futures klines."""
        params: Dict[str, Any] = {"symbol": symbol.upper(), "interval": interval, "limit": int(limit)}
        if start_time is not None:
            params["startTime"] = int(start_time)
        if end_time is not None:
            params["endTime"] = int(end_time)
        logger.debug("Futures: klines %s interval=%s start=%s end=%s limit=%s", symbol, interval, start_time, end_time, limit)
        data = await self._http.get(FUTURES_KLINE_ENDPOINT, params=params, futures=True)
        return data  # type: ignore[return-value]


# ==== binance_pb_index.py ====

"""
utils/binance/binance_pb_index.py
--------------------------------
Index / Mark Price related public endpoints.

- Mark price / index / premium endpoints (futures) ve ilgili public index verilerini getirir.
- Async / singleton / logging
- Not: bazı index endpoints Binance docs'a göre futures domain altında (/fapi/v1/...).
"""

from __future__ import annotations

import logging
from typing import Any, Dict, List, Optional

from .binance_request import BinanceHTTPClient

logger = logging.getLogger(__name__)

# Common futures index endpoints (public)
FAPI_MARK_PRICE_ENDPOINT = "/fapi/v1/premiumIndex"  # premiumIndex contains mark/premium data
FAPI_INDEX_PRICE_ENDPOINT = "/api/v3/indexPrice"  # if needed in other setups; keep optional
FAPI_FUNDING_RATE_ENDPOINT = "/fapi/v1/fundingRate"

class BinancePBIndex:
    """
    Wrapper for index and mark-price related public endpoints.
    """

    _instance: Optional["BinancePBIndex"] = None

    def __init__(self, http_client: Optional[BinanceHTTPClient] = None) -> None:
        self._http = http_client or BinanceHTTPClient()
        logger.debug("BinancePBIndex initialized")

    @classmethod
    def get_instance(cls, http_client: Optional[BinanceHTTPClient] = None) -> "BinancePBIndex":
        if cls._instance is None:
            cls._instance = cls(http_client=http_client)
        elif http_client is not None:
            cls._instance._http = http_client
        return cls._instance

    async def mark_price(self, symbol: Optional[str] = None) -> Any:
        """
        Get current mark/premium index.
        If symbol is provided returns single object, otherwise list for all symbols.
        """
        params = {"symbol": symbol.upper()} if symbol else None
        logger.debug("Index: mark_price %s", symbol)
        data = await self._http.get(FAPI_MARK_PRICE_ENDPOINT, params=params, futures=True)
        return data

    async def funding_rate_history(
        self,
        symbol: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: int = 100,
    ) -> List[Dict[str, Any]]:
        """
        Funding rate history for a symbol (futures).
        """
        params: Dict[str, Any] = {"limit": int(limit)}
        if symbol:
            params["symbol"] = symbol.upper()
        if start_time:
            params["startTime"] = int(start_time)
        if end_time:
            params["endTime"] = int(end_time)
        logger.debug("Index: funding_rate_history %s params=%s", symbol, params)
        data = await self._http.get(FAPI_FUNDING_RATE_ENDPOINT, params=params, futures=True)
        return data  # type: ignore[return-value]


# ==== binance_pb_spot.py ====

"""
utils/binance/binance_pb_spot.py
--------------------------------
Spot (public) endpoints wrapper.

- Sadece public spot market verilerine ait endpointleri içerir.
- Async / aiohttp tabanlı BinanceHTTPClient ile çalışır.
- Singleton pattern ile instance yönetimi.
- PEP8, type hints, docstrings ve logging içerir.
"""

from __future__ import annotations

import logging
from typing import Any, Dict, List, Optional

from .binance_request import BinanceHTTPClient
from .binance_constants import (
    SPOT_PING_ENDPOINT,
    SPOT_TIME_ENDPOINT,
    SPOT_EXCHANGE_INFO_ENDPOINT,
    SPOT_ORDER_BOOK_ENDPOINT,
    SPOT_KLINE_ENDPOINT,
    SPOT_AGG_TRADE_ENDPOINT,
    SPOT_TICKER_24H_ENDPOINT,
    SPOT_TICKER_PRICE_ENDPOINT,
    SPOT_TICKER_BOOK_ENDPOINT,
)
from .binance_types import ExchangeInfo, Kline, OrderBook, Ticker, Trade

logger = logging.getLogger(__name__)


class BinancePBSpot:
    """
    Public-Spot (PB) wrapper exposing commonly used public endpoints.

    Usage:
        client = BinancePBSpot.get_instance(http_client=BinanceHTTPClient(...))
        await client.ping()
    """

    _instance: Optional["BinancePBSpot"] = None

    def __init__(self, http_client: Optional[BinanceHTTPClient] = None) -> None:
        """
        Create a wrapper instance. If http_client is not provided, an internal
        default BinanceHTTPClient() will be created (without API keys, since public).
        """
        self._http = http_client or BinanceHTTPClient()
        logger.debug("BinancePBSpot initialized")

    @classmethod
    def get_instance(cls, http_client: Optional[BinanceHTTPClient] = None) -> "BinancePBSpot":
        """Return singleton instance (optionally supplying an http client)."""
        if cls._instance is None:
            cls._instance = cls(http_client=http_client)
        elif http_client is not None:
            # allow replacing underlying client if explicitly provided first time
            cls._instance._http = http_client
        return cls._instance

    # -------------------------
    # System / simple helpers
    # -------------------------
    async def ping(self) -> bool:
        """
        Ping endpoint - returns True if Binance responds.
        """
        logger.debug("Spot: ping")
        await self._http.get(SPOT_PING_ENDPOINT)
        return True

    async def server_time(self) -> int:
        """
        Get server time (ms).
        """
        logger.debug("Spot: server_time")
        data = await self._http.get(SPOT_TIME_ENDPOINT)
        ts = int(data.get("serverTime", 0))
        logger.debug("Spot server time: %s", ts)
        return ts

    async def exchange_info(self, symbol: Optional[str] = None) -> ExchangeInfo:
        """
        Return exchangeInfo (optionally filtered by symbol).
        """
        params = {"symbol": symbol} if symbol else None
        logger.debug("Spot: exchange_info (%s)", symbol)
        data = await self._http.get(SPOT_EXCHANGE_INFO_ENDPOINT, params=params)
        # Type hinting to ExchangeInfo (caller should validate)
        return data  # type: ignore[return-value]

    # -------------------------
    # Market Data
    # -------------------------
    async def order_book(self, symbol: str, limit: int = 100) -> OrderBook:
        """
        Get order book for a symbol.
        limit allowed: up to 1000 (Binance); default 100.
        """
        params = {"symbol": symbol.upper(), "limit": int(limit)}
        logger.debug("Spot: order_book %s limit=%s", symbol, limit)
        data = await self._http.get(SPOT_ORDER_BOOK_ENDPOINT, params=params)
        return data  # type: ignore[return-value]

    async def klines(
        self,
        symbol: str,
        interval: str,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: int = 500,
    ) -> List[Kline]:
        """
        Get klines/candles.
        """
        params: Dict[str, Any] = {
            "symbol": symbol.upper(),
            "interval": interval,
            "limit": int(limit),
        }
        if start_time is not None:
            params["startTime"] = int(start_time)
        if end_time is not None:
            params["endTime"] = int(end_time)
        logger.debug("Spot: klines %s interval=%s start=%s end=%s limit=%s", symbol, interval, start_time, end_time, limit)
        data = await self._http.get(SPOT_KLINE_ENDPOINT, params=params)
        # Binance returns list[list]; caller may map to Kline TypedDict if desired
        return data  # type: ignore[return-value]

    async def agg_trades(
        self,
        symbol: str,
        from_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: int = 500,
    ) -> List[Trade]:
        """
        Aggregated trades list.
        """
        params: Dict[str, Any] = {"symbol": symbol.upper(), "limit": int(limit)}
        if from_id is not None:
            params["fromId"] = int(from_id)
        if start_time is not None:
            params["startTime"] = int(start_time)
        if end_time is not None:
            params["endTime"] = int(end_time)
        logger.debug("Spot: agg_trades %s params=%s", symbol, params)
        data = await self._http.get(SPOT_AGG_TRADE_ENDPOINT, params=params)
        return data  # type: ignore[return-value]

    async def ticker_24hr(self, symbol: Optional[str] = None) -> Any:
        """
        24hr ticker price change statistics.
        If symbol is None returns array for all symbols.
        """
        params = {"symbol": symbol.upper()} if symbol else None
        logger.debug("Spot: ticker_24hr %s", symbol)
        data = await self._http.get(SPOT_TICKER_24H_ENDPOINT, params=params)
        return data

    async def ticker_price(self, symbol: Optional[str] = None) -> Any:
        """
        Current average price for symbol(s).
        """
        params = {"symbol": symbol.upper()} if symbol else None
        logger.debug("Spot: ticker_price %s", symbol)
        data = await self._http.get(SPOT_TICKER_PRICE_ENDPOINT, params=params)
        return data

    async def ticker_book(self, symbol: Optional[str] = None) -> Any:
        """
        Best bid/ask for symbol(s).
        """
        params = {"symbol": symbol.upper()} if symbol else None
        logger.debug("Spot: ticker_book %s", symbol)
        data = await self._http.get(SPOT_TICKER_BOOK_ENDPOINT, params=params)
        return data


# ==== binance_pb_system.py ====

"""
utils/binance/binance_pb_system.py
---------------------------------
System related public endpoints and helpers.

- Exchange info, ping, health helpers and small convenience wrappers.
- Kullanıcıların hem spot hem futures için ortak system işlemlerini sağlar.
- Async / singleton / logging
"""

from __future__ import annotations

import logging
from typing import Any, Dict, Optional

from .binance_request import BinanceHTTPClient
from .binance_constants import (
    SPOT_PING_ENDPOINT,
    SPOT_TIME_ENDPOINT,
    SPOT_EXCHANGE_INFO_ENDPOINT,
    FUTURES_PING_ENDPOINT,
    FUTURES_TIME_ENDPOINT,
    FUTURES_EXCHANGE_INFO_ENDPOINT,
)
from .binance_metrics import AdvancedMetrics
from .binance_types import ExchangeInfo

logger = logging.getLogger(__name__)


class BinancePBSystem:
    """
    System helpers for both Spot and Futures public endpoints.

    Responsibilities:
    - ping/time for spot & futures
    - exchange_info shortcuts
    - small health check using metrics module
    """

    _instance: Optional["BinancePBSystem"] = None

    def __init__(self, http_client: Optional[BinanceHTTPClient] = None) -> None:
        self._http = http_client or BinanceHTTPClient()
        self._metrics = AdvancedMetrics.get_instance()
        logger.debug("BinancePBSystem initialized")

    @classmethod
    def get_instance(cls, http_client: Optional[BinanceHTTPClient] = None) -> "BinancePBSystem":
        if cls._instance is None:
            cls._instance = cls(http_client=http_client)
        elif http_client is not None:
            cls._instance._http = http_client
        return cls._instance

    async def ping_spot(self) -> bool:
        """Ping spot public endpoint."""
        logger.debug("System: ping_spot")
        await self._http.get(SPOT_PING_ENDPOINT)
        return True

    async def ping_futures(self) -> bool:
        """Ping futures public endpoint."""
        logger.debug("System: ping_futures")
        await self._http.get(FUTURES_PING_ENDPOINT, futures=True)
        return True

    async def server_time_spot(self) -> int:
        logger.debug("System: server_time_spot")
        data = await self._http.get(SPOT_TIME_ENDPOINT)
        return int(data.get("serverTime", 0))

    async def server_time_futures(self) -> int:
        logger.debug("System: server_time_futures")
        data = await self._http.get(FUTURES_TIME_ENDPOINT, futures=True)
        return int(data.get("serverTime", 0))

    async def exchange_info_spot(self, symbol: Optional[str] = None) -> ExchangeInfo:
        logger.debug("System: exchange_info_spot %s", symbol)
        params = {"symbol": symbol} if symbol else None
        return await self._http.get(SPOT_EXCHANGE_INFO_ENDPOINT, params=params)  # type: ignore[return-value]

    async def exchange_info_futures(self, symbol: Optional[str] = None) -> ExchangeInfo:
        logger.debug("System: exchange_info_futures %s", symbol)
        params = {"symbol": symbol} if symbol else None
        return await self._http.get(FUTURES_EXCHANGE_INFO_ENDPOINT, params=params, futures=True)  # type: ignore[return-value]

    async def health_check(self) -> Dict[str, Any]:
        """
        Combined health check using metrics (AdvancedMetrics).
        Returns dict with status, issues, metrics.
        """
        logger.debug("System: health_check")
        return await self._metrics.get_health_status()


