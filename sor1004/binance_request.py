# utils/binance/binance_request.py
import aiohttp
import asyncio
import time
import logging
import hashlib
import hmac
import urllib.parse
import json
import platform
import os
from typing import Dict, Any, Optional, Union, Callable, Awaitable, List
from contextlib import asynccontextmanager

# APIKey IMPORT
try:
    from ..apikey_manager import APIKeyManager  # Relative import
except ImportError:
    # Fallback için absolute import
    from utils.apikey_manager import APIKeyManager


from .binance_constants import (
    BASE_URL, FUTURES_URL, DEFAULT_CONFIG, ENDPOINT_WEIGHT_MAP,
    TESTNET_BASE_URL, TESTNET_FUTURES_URL, MARGIN_URL
)


from .binance_exceptions import (
    BinanceAPIError, BinanceRequestError, BinanceRateLimitError,
    BinanceAuthenticationError, BinanceTimeoutError,
    BinanceOrderRejectedError, BinanceInvalidSymbolError,
    BinanceServerError, BinanceConnectionError  # EKLENDİ
)

from .binance_metrics import AdvancedMetrics as MetricsManager
from .binance_metrics import record_response, record_retry


logger = logging.getLogger(__name__)


class BinanceHTTPClient:
    """
    Enhanced async HTTP client for Binance API with retry logic, dynamic rate limiting,
    detailed error handling, and optional metrics tracking.
    """

    def __init__(
        self,
        api_key: Optional[str] = None,
        secret_key: Optional[str] = None,
        base_url: Optional[str] = None,
        fapi_url: Optional[str] = None,
        config: Optional[Dict[str, Any]] = None,
        session: Optional[aiohttp.ClientSession] = None,
        testnet: bool = False,  # testnet desteği
        user_id: Optional[int] = None  # user tracking
    ):
        self.api_key = api_key
        self.secret_key = secret_key
        self.user_id = user_id  
        #  testnet URL seçimi
        if testnet:
            self.base_url = base_url or TESTNET_BASE_URL
            self.fapi_url = fapi_url or TESTNET_FUTURES_URL
        else:
            self.base_url = base_url or BASE_URL
            self.fapi_url = fapi_url or FUTURES_URL
            
        self.config = {**DEFAULT_CONFIG, **(config or {})}
        self._session_provided_externally = session is not None
        self._session = session
        self._last_request_time = 0
        self._min_request_interval = 1.0 / self.config.get("requests_per_second", 10)
        self._weight_used = 0
        self._weight_reset_time = time.time() + 60
        self._weight_limit = 1200
        self._concurrent_requests = 0
        self._max_concurrent_requests = self.config.get("max_concurrent_requests", 10)
        self._request_semaphore = asyncio.Semaphore(self._max_concurrent_requests)
        
        self.metrics = MetricsManager.get_instance()
        

        # __init__ metodunda: INFO: İş mantığı olayları (başlatma, doğrulama, kapatma)
        logger.info(
            f"BinanceHTTPClient initialized - "
            f"user:{self.user_id} "
            f"base_url:{self.base_url} "
            f"testnet:{testnet} "
            f"rate_limit:{self.config.get('requests_per_second')}req/s"
        )

        
#-------------------------------------
#---------apikey işlemleri------------
    # User info getter
    def get_user_info(self) -> Dict[str, Any]:
        """Get user information for logging and tracking."""
        return {
            'user_id': self.user_id,
            'api_key_prefix': self.api_key[:8] + '...' if self.api_key else None,
            'testnet': self.is_testnet(),
            'base_url': self.base_url
        }

 
    # User-based client factory - Create Methods
    @classmethod
    async def create_for_user(
        cls,
        user_id: int,
        config: Optional[Dict[str, Any]] = None,
        session: Optional[aiohttp.ClientSession] = None,
        testnet: bool = False
    ) -> "BinanceHTTPClient":
        """
        Create client using API keys from database for specific user.
        """
        api_manager = APIKeyManager.get_instance()
        credentials = await api_manager.get_apikey(user_id)
        
        if not credentials:
            raise BinanceAuthenticationError(f"No API credentials found for user {user_id}")
        
        api_key, secret_key = credentials
        
        # User ID ile client oluştur
        client = cls(
            api_key=api_key,
            secret_key=secret_key,
            config=config,
            session=session,
            testnet=testnet,
            user_id=user_id  # EKLENDİ
        )
        
        logger.info(f"Binance client created - user:{user_id} testnet:{testnet}")
        return client
        
    
    @classmethod
    async def create_with_keys(
        cls,
        api_key: str,
        secret_key: str,
        config: Optional[Dict[str, Any]] = None,
        session: Optional[aiohttp.ClientSession] = None,
        testnet: bool = False,
        user_id: Optional[int] = None  # ✅
    ) -> "BinanceHTTPClient":
        """
        Create client with explicit API keys (for temporary usage).
        """
        return cls(
            api_key=api_key,
            secret_key=secret_key,
            config=config,
            session=session,
            testnet=testnet,
            user_id=user_id
        )
        

    # API Key validation
    async def validate_credentials(self, futures: bool = False) -> Dict[str, Any]:
        """
        Validate API credentials by making a test request.
        Returns detailed validation result.
        """
        try:
            if futures:
                # Futures account info için
                account_info = await self.get('/fapi/v2/account', signed=True, futures=True)
                validation_result = {
                    'valid': True,
                    'can_trade': account_info.get('canTrade', False),
                    'can_withdraw': account_info.get('canWithdraw', False),
                    'can_deposit': account_info.get('canDeposit', False),
                    'account_type': 'futures',
                    'update_time': account_info.get('updateTime')
                }
            else:
                # Spot account info için
                account_info = await self.get('/api/v3/account', signed=True)
                validation_result = {
                    'valid': True,
                    'can_trade': account_info.get('canTrade', False),
                    'can_withdraw': account_info.get('canWithdraw', False),
                    'can_deposit': account_info.get('canDeposit', False),
                    'account_type': 'spot',
                    'permissions': account_info.get('permissions', []),
                    'balances': len(account_info.get('balances', [])),
                    'update_time': account_info.get('updateTime')
                }
            
            # Başarılı doğrulama logu
            logger.info(
                f"API credentials validated - "
                f"user:{self.user_id} "
                f"type:{validation_result['account_type']} "
                f"permissions:{validation_result.get('permissions', [])}"
            )
            return validation_result
            
        except BinanceAuthenticationError as e:
            logger.error(f"❌ API credential validation failed: {e}")
            validation_result = {
                'valid': False,
                'error': 'authentication_failed',
                'message': str(e)
            }
            
            # Hata logu
            logger.error(
                f"API validation failed - "
                f"user:{self.user_id} "
                f"error:{validation_result.get('error')} "
                f"message:{validation_result.get('message')}"
            )
            return validation_result
            
        except Exception as e:
            logger.error(f"API validation error for user_{self.user_id} error:{str(e)}")
            validation_result = {
                'valid': False,
                'error': 'validation_error', 
                'message': str(e)
            }
            
            # Hata logu
            logger.error(
                f"API validation failed - "
                f"user:{self.user_id} "
                f"error:{validation_result.get('error')} "
                f"message:{validation_result.get('message')}"
            )
            return validation_result
            



    # Enhanced account methods for multi-user support
    async def get_account_info(self, futures: bool = False) -> Dict[str, Any]:
        """
        Get comprehensive account information.
        """
        endpoint = "/fapi/v2/account" if futures else "/api/v3/account"
        return await self.get(endpoint, signed=True, futures=futures)
    
    async def get_balance(self, asset: Optional[str] = None, futures: bool = False) -> Union[Dict[str, Any], List[Dict[str, Any]]]:
        """
        Get account balance for specific asset or all balances.
        """
        account_info = await self.get_account_info(futures=futures)
        
        if futures:
            balances = account_info.get('assets', [])
        else:
            balances = account_info.get('balances', [])
        
        if asset:
            # Specific asset balance
            asset_upper = asset.upper()
            balance = next(
                (b for b in balances if b['asset'].upper() == asset_upper), 
                {'asset': asset, 'free': '0', 'locked': '0'}
            )
            return balance
        else:
            # All balances (filter out zero balances for spot)
            if futures:
                return balances
            else:
                return [b for b in balances if float(b['free']) > 0 or float(b['locked']) > 0]
    
    async def get_open_orders(self, symbol: Optional[str] = None, futures: bool = False) -> List[Dict[str, Any]]:
        """
        Get current open orders.
        """
        endpoint = "/fapi/v1/openOrders" if futures else "/api/v3/openOrders"
        params = {}
        if symbol:
            params['symbol'] = symbol.upper()
        
        return await self.get(endpoint, params=params, signed=True, futures=futures)
    
    async def get_order_history(self, symbol: Optional[str] = None, futures: bool = False, limit: int = 50) -> List[Dict[str, Any]]:
        """
        Get order history.
        """
        endpoint = "/fapi/v1/allOrders" if futures else "/api/v3/allOrders"
        params = {'limit': limit}
        if symbol:
            params['symbol'] = symbol.upper()
        
        return await self.get(endpoint, params=params, signed=True, futures=futures)


    # User context manager
    @classmethod
    @asynccontextmanager
    async def user_session(
        cls,
        user_id: int,
        config: Optional[Dict[str, Any]] = None,
        session: Optional[aiohttp.ClientSession] = None,  # EKLENDİ
        testnet: bool = False
    ):
        """
        Context manager for user-based sessions.
        Automatically handles client creation and cleanup.
        """
        client = None
        try:
            client = await cls.create_for_user(
                user_id=user_id, 
                config=config, 
                session=session,  # EKLENDİ
                testnet=testnet
            )
            yield client
        except Exception as e:
            # Session hataları:
            logger.error(f"User session creation failed for user_{user_id} - error:{str(e)}")
            raise
        finally:
            if client:
                await client.close()
                
                
    # Config validation 
    def _validate_config(self):
        required_keys = ['timeout', 'max_retries', 'recv_window']
        for key in required_keys:
            if key not in self.config:
                raise ValueError(f"Missing required config key: {key}")


##2
    async def _get_session(self) -> aiohttp.ClientSession:
        if self._session is None or self._session.closed:
            timeout = aiohttp.ClientTimeout(
                total=self.config["timeout"],
                connect=self.config.get("connect_timeout", 5),
                sock_connect=self.config.get("sock_connect_timeout", 5),
                sock_read=self.config.get("sock_read_timeout", 10)
            )
            connector = aiohttp.TCPConnector(
                limit=self.config.get("connector_limit", 100),
                limit_per_host=self.config.get("connector_limit_per_host", 20),
                enable_cleanup_closed=True,
                keepalive_timeout=30  # Keep-alive timeout eklendi
            )
            self._session = aiohttp.ClientSession(
                timeout=timeout, 
                connector=connector,
                headers={
                    'User-Agent': f'BinancePythonClient/1.0 (Python {platform.python_version()})'
                }
            )
            logger.debug(f"New aiohttp session created for user_{self.user_id} - connector_limit: {self.config.get('connector_limit')}")
        return self._session

    async def close(self) -> None:
        """Close session and cleanup resources."""
        if self._session and not self._session.closed and not self._session_provided_externally:
            await self._session.close()
            self._session = None

            # Session kapatma:
            logger.info(f"BinanceHTTPClient session closed - user:{self.user_id} total_requests:{self.metrics.get_total_requests()}")


    def _generate_signature(self, params: Dict[str, Any]) -> str:
        """Generate HMAC SHA256 signature for private endpoints."""
        if not self.secret_key:
            raise BinanceAuthenticationError("Secret key required for signed requests")
        
        # Parametreleri sırala ve encode et
        query_string = urllib.parse.urlencode(sorted(params.items()))
        return hmac.new(
            self.secret_key.encode('utf-8'),
            query_string.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()

    def _add_auth_headers(self, headers: Dict[str, str]) -> Dict[str, str]:
        """Add authentication headers to request."""
        if self.api_key:
            headers['X-MBX-APIKEY'] = self.api_key
        return headers

    async def _rate_limit(self, endpoint: Optional[str] = None) -> None:
        """Apply rate limiting based on endpoint weight and request interval."""
        # Endpoint weight kontrolü
        endpoint_weight = ENDPOINT_WEIGHT_MAP.get(endpoint, 1) if endpoint else 1
        current_time = time.time()
        
        # Weight reset kontrolü
        if current_time > self._weight_reset_time:
            self._weight_used = 0
            self._weight_reset_time = current_time + 60
            await self.metrics.reset_rate_limits(reset_1m=True)
        
        # Weight limit kontrolü
        if self._weight_used + endpoint_weight > self._weight_limit:
            sleep_time = max(0, self._weight_reset_time - current_time)
            logger.warning(f"⚠️ Weight limit reached, sleeping for {sleep_time:.2f}s")
            await asyncio.sleep(sleep_time)
            self._weight_used = 0
            self._weight_reset_time = time.time() + 60

        # Minimum request interval kontrolü
        time_since_last = current_time - self._last_request_time
        if time_since_last < self._min_request_interval:
            await asyncio.sleep(self._min_request_interval - time_since_last)
        
        self._last_request_time = time.time()


    async def _handle_rate_limit(self, response_headers: Dict[str, str], endpoint: str) -> None:
        """Update rate limit metrics from response headers."""
        try:
            # Weight parsing from various header formats
            weight_headers = {
                'X-MBX-USED-WEIGHT': 'weight_used_1m',
                'X-MBX-USED-WEIGHT-1M': 'weight_used_1m', 
                'X-MBX-USED-WEIGHT-1m': 'weight_used_1m',
                'X-MBX-USED-WEIGHT-1S': 'weight_used_1s',
                'X-MBX-USED-WEIGHT-1s': 'weight_used_1s'
            }
            
            # ✅ TEK METRICS KAYDI (duplicate kaldırıldı)
            weight_hint = ENDPOINT_WEIGHT_MAP.get(endpoint, 1)
            await record_response(
                endpoint=endpoint,
                headers=response_headers,
                weight_hint=weight_hint
            )
        except Exception as e:
            logger.warning(f"Failed parsing rate limit headers: {e}")

        
            #weight_1m = None
            #weight_1s = None
            
            for header_key, weight_type in weight_headers.items():
                if header_key in response_headers:
                    try:
                        weight_value = int(response_headers[header_key])
                        if weight_type == 'weight_used_1m':
                            weight_1m = weight_value
                            self._weight_used = weight_value  # Absolute value from header
                        elif weight_type == 'weight_used_1s':
                            weight_1s = weight_value
                    except (ValueError, TypeError):
                        continue

            # Weight limit headers
            weight_limit_headers = ['X-MBX-WEIGHT-LIMIT', 'X-MBX-WEIGHT-LIMIT-1M']
            for header_key in weight_limit_headers:
                if header_key in response_headers:
                    try:
                        self._weight_limit = int(response_headers[header_key])
                        break
                    except (ValueError, TypeError):
                        continue

            # Metrics kaydı için weight bilgisi
            weight_hint = ENDPOINT_WEIGHT_MAP.get(endpoint, 1)
            await record_response(
                endpoint=endpoint,
                headers=response_headers,
                weight_hint=weight_hint
            )


            # Order count limits
            order_count_1s = response_headers.get('X-MBX-ORDER_COUNT-1S')
            order_count_1m = response_headers.get('X-MBX-ORDER_COUNT-1M')
            
            # Metrics kaydı
            await record_response(
                endpoint=endpoint,
                headers=response_headers,
                weight_hint=ENDPOINT_WEIGHT_MAP.get(endpoint, 1)
            )

        except Exception as e:
            logger.warning(f"Failed parsing rate limit headers: {e}")
            

    async def _handle_error(self, status_code: int, error_data: str, response_time: float, endpoint: str) -> None:
        """Handle API errors and map to specific exceptions."""
        try:
            error_json = json.loads(error_data) if error_data else {}
            code = error_json.get('code', -1)
            msg = error_json.get('msg', 'Unknown error')
            
            # EKLENDİ - Metrics kaydı
            await record_response(
                endpoint=endpoint,
                status_code=status_code,
                response_body=error_json,
                error=BinanceAPIError(msg, code, error_json)
            )

            # Enhanced error mapping
            error_mappings = {
                400: BinanceRequestError,
                401: BinanceAuthenticationError,
                403: BinanceAuthenticationError,
                404: BinanceRequestError,
                405: BinanceRequestError,
                415: BinanceRequestError,
                429: BinanceRateLimitError,
                418: BinanceAPIError,  # IP banned
                419: BinanceAPIError,  # API banned
                500: BinanceServerError,
                502: BinanceServerError,
                503: BinanceServerError,
                504: BinanceServerError,
            }
            
            # Enhanced Binance specific codes
            specific_codes = {
                -1000: BinanceRequestError,   # UNKNOWN
                -1001: BinanceConnectionError, # DISCONNECTED
                -1002: BinanceAuthenticationError, # UNAUTHORIZED
                -1003: BinanceRateLimitError,  # TOO_MANY_REQUESTS
                -1006: BinanceRequestError,    # UNEXPECTED_RESP
                -1007: BinanceRequestError,    # TIMEOUT
                -1010: BinanceAPIError,        # ERROR_MSG_RECEIVED
                -1013: BinanceInvalidSymbolError, # INVALID_MESSAGE
                -1014: BinanceOrderRejectedError, # UNKNOWN_ORDER_COMPOSITION
                -1015: BinanceRateLimitError,  # TOO_MANY_ORDERS
                -1020: BinanceRequestError,    # UNSUPPORTED_OPERATION
                -1021: BinanceAPIError,        # INVALID_TIMESTAMP
                -1022: BinanceAuthenticationError, # INVALID_SIGNATURE
                -1100: BinanceRequestError,    # ILLEGAL_CHARS
                -1101: BinanceRequestError,    # TOO_MANY_PARAMETERS
                -1102: BinanceRequestError,    # MANDATORY_PARAM_EMPTY_OR_MALFORMED
                -2010: BinanceOrderRejectedError, # NEW_ORDER_REJECTED
                -2011: BinanceOrderRejectedError, # CANCEL_REJECTED
                -2013: BinanceInvalidSymbolError, # NO_SUCH_ORDER
                -2014: BinanceAuthenticationError, # BAD_API_KEY_FMT
                -2015: BinanceAuthenticationError, # REJECTED_MBX_KEY
            }
            
            exception_class = None
            if status_code in error_mappings:
                exception_class = error_mappings[status_code]
            elif code in specific_codes:
                exception_class = specific_codes[code]
            elif status_code >= 400:
                exception_class = BinanceAPIError
                
            if exception_class:
                raise exception_class(msg, code, error_json)
            else:
                raise BinanceAPIError(msg, code, error_json)
                
        except (ValueError, json.JSONDecodeError):
            # EKLENDİ - Invalid response için metrics
            await record_response(
                endpoint=endpoint,
                status_code=status_code,
                response_body=error_data,
                error=BinanceRequestError(f"HTTP {status_code}: Invalid response")
            )
            raise BinanceRequestError(f"HTTP {status_code}: Invalid response: {error_data}")
            



    @asynccontextmanager
    async def _concurrent_request_limiter(self):
        """Limit concurrent requests using semaphore."""
        async with self._request_semaphore:
            self._concurrent_requests += 1
            try:
                yield
            finally:
                self._concurrent_requests -= 1


    async def _request(
        self,
        method: str,
        endpoint: str,
        params: Optional[Dict[str, Any]] = None,
        signed: bool = False,
        futures: bool = False,
        retries: Optional[int] = None,
        timeout: Optional[float] = None
    ) -> Union[Dict[str, Any], List[Any]]:
        """Internal request method with retry logic and error handling."""
        
        # User context için enhanced logging
        # _request metodunda:DEBUG: Detaylı teknik bilgiler (session, connector, parametreler)
        user_context = f"user_{self.user_id}" if self.user_id else "anonymous"
        logger.debug(f"Request started - {user_context} {method} {endpoint} params:{params}")


        
        retries = retries if retries is not None else self.config["max_retries"]
        params = params or {}
        
        if not isinstance(params, dict):
            raise BinanceRequestError("Params must be a dict")

        base_url = self.fapi_url if futures else self.base_url
        url = f"{base_url}{endpoint}"
        headers = {
            'Content-Type': 'application/json',
            'User-Agent': f'BinancePythonClient/1.0 (Python {platform.python_version()})'
        }

        # Signature for private endpoints
        if signed:
            params = params.copy()
            params['timestamp'] = int(time.time() * 1000)
            params.setdefault('recvWindow', self.config["recv_window"])
            params['signature'] = self._generate_signature(params)
        
        headers = self._add_auth_headers(headers)

        last_exception = None
        for attempt in range(retries + 1):
            start_time = time.time()  # EKLENDİ - start time metrics için
            try:
                async with self._concurrent_request_limiter():
                    await self._rate_limit(endpoint)
                    session = await self._get_session()
                    
                    request_params = {
                        'method': method.upper(),
                        'url': url,
                        'headers': headers,
                    }

                    # GET vs POST parametreleri
                    if method.upper() == 'GET':
                        request_params['params'] = params
                    else:
                        if signed:
                            request_params['data'] = urllib.parse.urlencode(params)
                            headers['Content-Type'] = 'application/x-www-form-urlencoded'
                        else:
                            request_params['json'] = params

                    # Timeout ayarı
                    request_timeout = aiohttp.ClientTimeout(total=timeout or self.config['timeout'])
                    request_params['timeout'] = request_timeout

                    async with session.request(**request_params) as response:
                        response_time = time.time() - start_time
                        await self._handle_rate_limit(response.headers, endpoint)  # EKLENDİ - endpoint parametresi
                        
                        if response.status == 200:
                            data = await response.json()
                            # EKLENDİ - Başarılı request için metrics
                            await record_response(
                                endpoint=endpoint,
                                status_code=response.status,
                                response_body=data,
                                headers=dict(response.headers),
                                start_time=start_time
                            )
                            return data
                            
                        error_text = await response.text()
                        await self._handle_error(response.status, error_text, response_time, endpoint)  # EKLENDİ - endpoint

            except asyncio.TimeoutError:
                last_exception = BinanceTimeoutError(f"Request timeout after {timeout}s")
                # EKLENDİ - Timeout için metrics
                await record_response(
                    endpoint=endpoint,
                    start_time=start_time,
                    error=last_exception
                )
            except aiohttp.ClientError as e:
                last_exception = BinanceRequestError(f"HTTP client error: {e}")
                # EKLENDİ - Client error için metrics
                await record_response(
                    endpoint=endpoint,
                    start_time=start_time,
                    error=last_exception
                )
            except (BinanceAPIError, BinanceAuthenticationError, BinanceRateLimitError) as e:
                # Bu hataları tekrar deneme (bazı durumlar hariç)
                if isinstance(e, BinanceRateLimitError) and attempt < retries:
                    sleep_time = min(60, self.config["retry_delay"] * (2 ** attempt))
                    logger.warning(f"Rate limited, sleeping for {sleep_time}s")
                    await asyncio.sleep(sleep_time)
                    # EKLENDİ - Retry kaydı
                    await record_retry(endpoint, attempt, False)
                    continue
                raise e
            except Exception as e:
                last_exception = BinanceRequestError(f"Unexpected error: {e}")
                # EKLENDİ - Unexpected error için metrics
                await record_response(
                    endpoint=endpoint,
                    start_time=start_time,
                    error=last_exception
                )

            # Retry logic
            if attempt < retries and last_exception:
                delay = self.config["retry_delay"] * (2 ** attempt)
                logger.warning(f"🔄 Retry {attempt+1}/{retries} for {method} {endpoint} after {delay:.2f}s")
                # EKLENDİ - Retry kaydı
                await record_retry(endpoint, attempt, False)
                await asyncio.sleep(delay)
            elif last_exception:
                raise last_exception
                



    # Public request methods
    async def get(self, endpoint: str, params: Optional[Dict[str, Any]] = None,
                  signed: bool = False, futures: bool = False, timeout: Optional[float] = None) -> Any:
        return await self._request('GET', endpoint, params, signed, futures, timeout=timeout)

    async def post(self, endpoint: str, params: Optional[Dict[str, Any]] = None,
                   signed: bool = False, futures: bool = False, timeout: Optional[float] = None) -> Any:
        return await self._request('POST', endpoint, params, signed, futures, timeout=timeout)

    async def put(self, endpoint: str, params: Optional[Dict[str, Any]] = None,
                  signed: bool = False, futures: bool = False, timeout: Optional[float] = None) -> Any:
        return await self._request('PUT', endpoint, params, signed, futures, timeout=timeout)

    async def delete(self, endpoint: str, params: Optional[Dict[str, Any]] = None,
                     signed: bool = False, futures: bool = False, timeout: Optional[float] = None) -> Any:
        return await self._request('DELETE', endpoint, params, signed, futures, timeout=timeout)

    # Utility methods
    async def health_check(self) -> Dict[str, Any]:
        """Check API connectivity and return detailed health status."""
        try:
            start_time = time.time()
            await self.get('/api/v3/ping', timeout=5)
            response_time = time.time() - start_time
            
            return {
                'status': 'healthy',
                'response_time': response_time,
                'weight_used': self._weight_used,
                'weight_remaining': self.get_weight_remaining(),
                'concurrent_requests': self._concurrent_requests
            }
        except Exception as e:
            logger.warning(f"Health check failed: {e}")
            return {
                'status': 'unhealthy',
                'error': str(e),
                'weight_used': self._weight_used,
                'concurrent_requests': self._concurrent_requests
            }

    def get_weight_usage(self) -> int:
        return self._weight_used

    def get_weight_remaining(self) -> int:
        return max(0, self._weight_limit - self._weight_used)

    def get_weight_limit(self) -> int:
        return self._weight_limit

    def get_concurrent_requests(self) -> int:
        return self._concurrent_requests

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()
 
 
     
    
    # yardımcı metodlar - (indentation)
    async def get_server_time(self, futures: bool = False) -> Dict[str, Any]:
        """Get server time for clock synchronization."""
        endpoint = "/fapi/v1/time" if futures else "/api/v3/time"
        return await self.get(endpoint)

    async def get_exchange_info(self, symbol: Optional[str] = None, futures: bool = False) -> Dict[str, Any]:
        """Get exchange information for symbols."""
        endpoint = "/fapi/v1/exchangeInfo" if futures else "/api/v3/exchangeInfo"
        params = {}
        if symbol:
            params['symbol'] = symbol
        return await self.get(endpoint, params=params)

    def is_testnet(self) -> bool:
        """Check if client is using testnet."""
        return TESTNET_BASE_URL in self.base_url or TESTNET_FUTURES_URL in self.fapi_url

    async def get_rate_limit_status(self) -> Dict[str, Any]:
        """Get current rate limit status."""
        return {
            'weight_used': self._weight_used,
            'weight_limit': self._weight_limit,
            'weight_remaining': self.get_weight_remaining(),
            'weight_reset_in': max(0, self._weight_reset_time - time.time()),
            'concurrent_requests': self._concurrent_requests,
            'max_concurrent_requests': self._max_concurrent_requests
        }
        




""" # utils/binance/binance_request.py
✅ Tüm Kritik Özellikler Mevcut:
Multi-user desteği - Dinamik API key yükleme
Rate limiting - Hem weight-based hem request-based
Error handling - Kapsamlı hata yönetimi
Metrics tracking - Detaylı monitoring
Hem spot hem futures - Çift piyasa desteği
Testnet desteği - Güvenli test ortamı
Context managers - Güvenli resource yönetimi
✅ Logging Mükemmel:
DEBUG: Detaylı teknik bilgiler
INFO: İş mantığı olayları
WARNING: Beklenen sorunlar
ERROR: Kritik hatalar
✅ Kod Kalitesi:
Temiz ve okunabilir
İyi documentasyon
Type hints mevcut
Modüler yapı
🚀 PRODUCTION-READY!


"""