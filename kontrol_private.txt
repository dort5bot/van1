dosyayı incele,

│   │   ├── binance_pr_**.py         # REST private  api endpointlerini gösterir
│   │   ├── binance_pr_asset.py
│   │   ├── binance_pr_base.py
│   │   ├── binance_pr_futures.py
│   │   ├── binance_pr_margin.py
│   │   ├── binance_pr_mining.py
│   │   ├── binance_pr_savings.py
│   │   ├── binance_pr_spot.py
│   │   ├── binance_pr_staking.py
│   │   ├── binance_pr_subaccount.py
│   │   ├── binance_pr_userstream.py

ayrı dosyalar halinde gruplandırılmış private endpointleri var.
eksik endpotler var mı varsa nelerdir,
binance api standartlarına uygun olarak isim değiştirmeden
eklenebilir halde ver
yapıya uygun şekilde ver





# ==== binance_pr_asset.py ====

# utils/binance/binance_pr_asset.py
"""
AssetClient: deposit/withdraw/dust + asset endpoints.
Binance API standardına uygun geliştirilmiş versiyon.
"""
from typing import Any, Dict, List, Optional, Union
import logging

from .binance_pr_base import BinancePrivateBase
from .binance_exceptions import BinanceAPIError

logger = logging.getLogger(__name__)


class AssetClient(BinancePrivateBase):
    """Deposit, withdraw, dust conversion, asset info and related operations."""

    # ----------------------------- DUST -----------------------------

    async def get_dust_log(
        self, start_time: Optional[int] = None, end_time: Optional[int] = None
    ) -> Dict[str, Any]:
        """GET /sapi/v1/asset/dribblet - Get conversion history (dust log)."""
        try:
            params = {}
            if start_time:
                params["startTime"] = start_time
            if end_time:
                params["endTime"] = end_time
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/asset/dribblet", params=params, signed=True
            )
        except Exception as e:
            logger.exception("Error getting dust log")
            raise BinanceAPIError("GET /sapi/v1/asset/dribblet failed", e)

    async def convert_dust(self, assets: List[str]) -> Dict[str, Any]:
        """POST /sapi/v1/asset/dust - Convert micro assets to BNB."""
        try:
            params = {"asset": [a.upper() for a in assets]}
            return await self.circuit_breaker.execute(
                self.http._request, "POST", "/sapi/v1/asset/dust", params=params, signed=True
            )
        except Exception as e:
            logger.exception("Error converting dust")
            raise BinanceAPIError("POST /sapi/v1/asset/dust failed", e)

    # ----------------------------- ASSET INFO -----------------------------

    async def get_asset_dividend(
        self, asset: Optional[str] = None, start_time: Optional[int] = None, end_time: Optional[int] = None
    ) -> Dict[str, Any]:
        """GET /sapi/v1/asset/assetDividend - Query asset dividend record."""
        try:
            params = {}
            if asset:
                params["asset"] = asset.upper()
            if start_time:
                params["startTime"] = start_time
            if end_time:
                params["endTime"] = end_time
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/asset/assetDividend", params=params, signed=True
            )
        except Exception as e:
            logger.exception("Error getting asset dividend")
            raise BinanceAPIError("GET /sapi/v1/asset/assetDividend failed", e)

    async def get_asset_detail(self) -> Dict[str, Any]:
        """GET /sapi/v1/asset/assetDetail - Query asset detail (withdraw/deposit status, fee)."""
        try:
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/asset/assetDetail", signed=True
            )
        except Exception as e:
            logger.exception("Error getting asset detail")
            raise BinanceAPIError("GET /sapi/v1/asset/assetDetail failed", e)

    async def get_trade_fee(self, symbol: Optional[str] = None) -> List[Dict[str, Any]]:
        """GET /sapi/v1/asset/tradeFee - Get trading fee."""
        try:
            params = {}
            if symbol:
                params["symbol"] = symbol.upper()
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/asset/tradeFee", params=params, signed=True
            )
        except Exception as e:
            logger.exception("Error getting trade fee")
            raise BinanceAPIError("GET /sapi/v1/asset/tradeFee failed", e)

    # ----------------------------- DEPOSIT -----------------------------

    async def get_deposit_address(self, coin: str, network: Optional[str] = None) -> Dict[str, Any]:
        """GET /sapi/v1/capital/deposit/address - Get deposit address."""
        try:
            params = {"coin": coin.upper()}
            if network:
                params["network"] = network
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/capital/deposit/address", params=params, signed=True
            )
        except Exception as e:
            logger.exception("Error getting deposit address")
            raise BinanceAPIError(f"GET /sapi/v1/capital/deposit/address failed for {coin}", e)

    async def get_deposit_history(
        self,
        coin: Optional[str] = None,
        status: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
    ) -> List[Dict[str, Any]]:
        """GET /sapi/v1/capital/deposit/hisrec - Get deposit history."""
        try:
            params = {}
            if coin:
                params["coin"] = coin.upper()
            if status is not None:
                params["status"] = status
            if start_time:
                params["startTime"] = start_time
            if end_time:
                params["endTime"] = end_time
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/capital/deposit/hisrec", params=params, signed=True
            )
        except Exception as e:
            logger.exception("Error getting deposit history")
            raise BinanceAPIError("GET /sapi/v1/capital/deposit/hisrec failed", e)

    async def get_all_coins_info(self) -> List[Dict[str, Any]]:
        """GET /sapi/v1/capital/config/getall - Get all coins info (network list, fee, enable status)."""
        try:
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/capital/config/getall", signed=True
            )
        except Exception as e:
            logger.exception("Error getting all coins info")
            raise BinanceAPIError("GET /sapi/v1/capital/config/getall failed", e)

    # ----------------------------- WITHDRAW -----------------------------

    async def get_withdraw_history(
        self,
        coin: Optional[str] = None,
        status: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
    ) -> List[Dict[str, Any]]:
        """GET /sapi/v1/capital/withdraw/history - Get withdraw history."""
        try:
            params = {}
            if coin:
                params["coin"] = coin.upper()
            if status is not None:
                params["status"] = status
            if start_time:
                params["startTime"] = start_time
            if end_time:
                params["endTime"] = end_time
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/capital/withdraw/history", params=params, signed=True
            )
        except Exception as e:
            logger.exception("Error getting withdraw history")
            raise BinanceAPIError("GET /sapi/v1/capital/withdraw/history failed", e)

    async def get_withdraw_address_list(self, coin: Optional[str] = None) -> List[Dict[str, Any]]:
        """GET /sapi/v1/capital/withdraw/address/list - Get withdraw address whitelist (if enabled)."""
        try:
            params = {}
            if coin:
                params["coin"] = coin.upper()
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/capital/withdraw/address/list", params=params, signed=True
            )
        except Exception as e:
            logger.exception("Error getting withdraw address list")
            raise BinanceAPIError("GET /sapi/v1/capital/withdraw/address/list failed", e)

    async def withdraw(
        self,
        coin: str,
        address: str,
        amount: Union[str, float],
        network: Optional[str] = None,
        address_tag: Optional[str] = None,
        wallet_type: Optional[int] = None,
        transaction_fee_flag: Optional[bool] = None,
        name: Optional[str] = None,
    ) -> Dict[str, Any]:
        """POST /sapi/v1/capital/withdraw/apply - Apply for withdraw.

        Required: coin, address, amount
        Optional: network, addressTag, walletType, transactionFeeFlag, name
        """
        try:
            params: Dict[str, Any] = {
                "coin": coin.upper(),
                "address": address,
                "amount": str(amount),  # API string bekliyor
            }
            if network:
                params["network"] = network
            if address_tag:
                params["addressTag"] = address_tag
            if wallet_type is not None:
                params["walletType"] = wallet_type
            if transaction_fee_flag is not None:
                params["transactionFeeFlag"] = str(transaction_fee_flag).lower()
            if name:
                params["name"] = name

            return await self.circuit_breaker.execute(
                self.http._request, "POST", "/sapi/v1/capital/withdraw/apply", params=params, signed=True
            )
        except Exception as e:
            logger.exception("Error withdrawing asset")
            raise BinanceAPIError(f"POST /sapi/v1/capital/withdraw/apply failed for {coin}", e)


# ==== binance_pr_base.py ====

"""
Common base for all private domain clients.
Includes http client, circuit breaker, key validation, and error handling.
"""
from typing import Any, Optional, Dict
import logging

from .binance_request import BinanceHTTPClient
from .binance_circuit_breaker import CircuitBreaker
from .binance_exceptions import (
    BinanceAPIError,
    BinanceAuthenticationError,
    BinanceRequestError,
    BinanceServerError,
    BinanceRateLimitError,
    BinanceBannedError,
    BinanceTimestampError,
)

logger = logging.getLogger(__name__)


class BinancePrivateBase:
    """
    Base class for private Binance clients.

    Attributes:
        http: BinanceHTTPClient instance
        circuit_breaker: CircuitBreaker instance
    """

    def __init__(self, http_client: BinanceHTTPClient, circuit_breaker: CircuitBreaker) -> None:
        self.http = http_client
        self.circuit_breaker = circuit_breaker

    def _require_keys(self) -> None:
        """Require API key and secret for private endpoints."""
        if not getattr(self.http, "api_key", None) or not getattr(self.http, "secret_key", None):
            logger.error("Binance API key/secret not found on http client")
            raise BinanceAuthenticationError("API key and secret required for private endpoints")

    async def _handle_response(self, response: Any) -> Any:
        """
        Parse Binance API response and raise appropriate errors.

        Args:
            response: HTTP response object (with .status and .json())
        Returns:
            Parsed response JSON
        Raises:
            BinanceAPIError or subclass depending on error
        """
        status = getattr(response, "status", None)
        try:
            data = await response.json()
        except Exception:
            data = None

        # --- HTTP Status-based handling ---
        if status == 400:
            raise BinanceRequestError("Bad request", status, data)
        if status in (401, 403):
            raise BinanceAuthenticationError("Unauthorized", status, data)
        if status == 418:
            raise BinanceBannedError("IP banned by Binance", status, data)
        if status == 429:
            await self.circuit_breaker.trip()
            raise BinanceRateLimitError("Rate limit exceeded", status, data)
        if status and status >= 500:
            raise BinanceServerError("Binance server error", status, data)

        # --- Binance JSON code-based handling ---
        if isinstance(data, dict) and "code" in data and data["code"] != 0:
            code = data.get("code")
            msg = data.get("msg", "Unknown Binance error")

            if code in (-2014, -2015):
                raise BinanceAuthenticationError(msg, code, data)
            if code == -1021:
                raise BinanceTimestampError(msg, code, data)
            if code == -1003:
                await self.circuit_breaker.trip()
                raise BinanceRateLimitError(msg, code, data)
            if -1199 <= code <= -1100:
                raise BinanceRequestError(msg, code, data)

            raise BinanceAPIError(msg, code, data)

        return data


# ==== binance_pr_futures.py ====

# utils/binance/binance_pr_futures.py
"""
FuturesClient: Binance USDT-M Coin-M futures endpoints (fapi).
Implements account info, positions, order placement/cancel, leverage changes, income history.
Full compliance with Binance Futures API standard.
"""
from typing import Any, Dict, List, Optional
import logging

from .binance_pr_base import BinancePrivateBase
from .binance_exceptions import BinanceAPIError

logger = logging.getLogger(__name__)


class FuturesClient(BinancePrivateBase):
    """Futures (fapi) operations."""

    # -------------------- Account & Balance --------------------
    async def get_account_info(self) -> Dict[str, Any]:
        """GET /fapi/v2/account"""
        try:
            await self._require_keys()
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/fapi/v2/account", signed=True, futures=True
            )
        except Exception as e:
            logger.exception("Error getting futures account info")
            raise BinanceAPIError(f"Error getting futures account info: {e}")

    async def get_balance(self) -> List[Dict[str, Any]]:
        """Return futures balances (assets list from account info)."""
        try:
            info = await self.get_account_info()
            return info.get("assets", [])
        except Exception as e:
            logger.exception("Error getting futures balance")
            raise BinanceAPIError(f"Error getting futures balance: {e}")

    async def get_positions(self) -> List[Dict[str, Any]]:
        """GET /fapi/v2/positionRisk"""
        try:
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/fapi/v2/positionRisk", signed=True, futures=True
            )
        except Exception as e:
            logger.exception("Error getting futures positions")
            raise BinanceAPIError(f"Error getting futures positions: {e}")

    # -------------------- Orders --------------------
    async def place_order(
        self,
        symbol: str,
        side: str,
        type_: str,
        quantity: Optional[float] = None,
        price: Optional[float] = None,
        reduce_only: Optional[bool] = None,
        time_in_force: Optional[str] = None,
        stop_price: Optional[float] = None,
        close_position: Optional[bool] = None,
        working_type: Optional[str] = None,
        price_protect: Optional[bool] = None,
        new_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[str] = None,
    ) -> Dict[str, Any]:
        """POST /fapi/v1/order"""
        try:
            await self._require_keys()
            params: Dict[str, Any] = {
                "symbol": symbol.upper(),
                "side": side,
                "type": type_,
            }
            if quantity is not None:
                params["quantity"] = quantity
            if price is not None:
                params["price"] = price
            if time_in_force:
                params["timeInForce"] = time_in_force
            if reduce_only is not None:
                params["reduceOnly"] = reduce_only
            if stop_price is not None:
                params["stopPrice"] = stop_price
            if close_position is not None:
                params["closePosition"] = close_position
            if working_type:
                params["workingType"] = working_type
            if price_protect is not None:
                params["priceProtect"] = price_protect
            if new_client_order_id:
                params["newClientOrderId"] = new_client_order_id
            if new_order_resp_type:
                params["newOrderRespType"] = new_order_resp_type

            return await self.circuit_breaker.execute(
                self.http._request, "POST", "/fapi/v1/order",
                params=params, signed=True, futures=True
            )
        except Exception as e:
            logger.exception("Error placing futures order")
            raise BinanceAPIError(f"Error placing futures order for {symbol}: {e}")

    async def test_order(self, **kwargs) -> Dict[str, Any]:
        """POST /fapi/v1/order/test (validate order parameters without placing)"""
        try:
            await self._require_keys()
            return await self.circuit_breaker.execute(
                self.http._request, "POST", "/fapi/v1/order/test",
                params=kwargs, signed=True, futures=True
            )
        except Exception as e:
            logger.exception("Error testing futures order")
            raise BinanceAPIError(f"Error testing futures order: {e}")

    async def cancel_order(
        self,
        symbol: str,
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
    ) -> Dict[str, Any]:
        """DELETE /fapi/v1/order"""
        try:
            params = {"symbol": symbol.upper()}
            if order_id:
                params["orderId"] = order_id
            if orig_client_order_id:
                params["origClientOrderId"] = orig_client_order_id
            return await self.circuit_breaker.execute(
                self.http._request, "DELETE", "/fapi/v1/order",
                params=params, signed=True, futures=True
            )
        except Exception as e:
            logger.exception("Error canceling futures order")
            raise BinanceAPIError(f"Error canceling futures order for {symbol}: {e}")

    async def get_open_orders(self, symbol: Optional[str] = None) -> List[Dict[str, Any]]:
        """GET /fapi/v1/openOrders"""
        try:
            params = {"symbol": symbol.upper()} if symbol else {}
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/fapi/v1/openOrders",
                params=params, signed=True, futures=True
            )
        except Exception as e:
            logger.exception("Error getting futures open orders")
            raise BinanceAPIError(f"Error getting futures open orders: {e}")

    async def get_order_history(
        self,
        symbol: str,
        limit: int = 50,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        order_id: Optional[int] = None,
    ) -> List[Dict[str, Any]]:
        """GET /fapi/v1/allOrders"""
        try:
            params: Dict[str, Any] = {"symbol": symbol.upper(), "limit": limit}
            if start_time:
                params["startTime"] = start_time
            if end_time:
                params["endTime"] = end_time
            if order_id:
                params["orderId"] = order_id
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/fapi/v1/allOrders",
                params=params, signed=True, futures=True
            )
        except Exception as e:
            logger.exception("Error getting futures order history")
            raise BinanceAPIError(f"Error getting futures order history for {symbol}: {e}")

    # -------------------- Income & Trades --------------------
    async def get_income_history(
        self,
        symbol: Optional[str] = None,
        income_type: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: int = 50,
    ) -> List[Dict[str, Any]]:
        """GET /fapi/v1/income"""
        try:
            params: Dict[str, Any] = {"limit": limit}
            if symbol:
                params["symbol"] = symbol.upper()
            if income_type:
                params["incomeType"] = income_type.upper()
            if start_time:
                params["startTime"] = start_time
            if end_time:
                params["endTime"] = end_time
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/fapi/v1/income",
                params=params, signed=True, futures=True
            )
        except Exception as e:
            logger.exception("Error getting futures income history")
            raise BinanceAPIError(f"Error getting futures income history: {e}")

    async def get_user_trades(
        self, symbol: str, limit: int = 50, from_id: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """GET /fapi/v1/userTrades"""
        try:
            params = {"symbol": symbol.upper(), "limit": limit}
            if from_id:
                params["fromId"] = from_id
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/fapi/v1/userTrades",
                params=params, signed=True, futures=True
            )
        except Exception as e:
            logger.exception("Error getting futures user trades")
            raise BinanceAPIError(f"Error getting futures user trades for {symbol}: {e}")

    # -------------------- Risk & Margin --------------------
    async def change_leverage(self, symbol: str, leverage: int) -> Dict[str, Any]:
        """POST /fapi/v1/leverage"""
        try:
            params = {"symbol": symbol.upper(), "leverage": leverage}
            return await self.circuit_breaker.execute(
                self.http._request, "POST", "/fapi/v1/leverage",
                params=params, signed=True, futures=True
            )
        except Exception as e:
            logger.exception("Error changing futures leverage")
            raise BinanceAPIError(f"Error changing leverage for {symbol}: {e}")

    async def get_leverage_bracket(self, symbol: Optional[str] = None) -> List[Dict[str, Any]]:
        """GET /fapi/v1/leverageBracket"""
        try:
            params = {"symbol": symbol.upper()} if symbol else {}
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/fapi/v1/leverageBracket",
                params=params, signed=True, futures=True
            )
        except Exception as e:
            logger.exception("Error getting leverage bracket")
            raise BinanceAPIError(f"Error getting leverage bracket: {e}")

    async def change_margin_type(self, symbol: str, margin_type: str) -> Dict[str, Any]:
        """POST /fapi/v1/marginType"""
        try:
            params = {"symbol": symbol.upper(), "marginType": margin_type.upper()}
            return await self.circuit_breaker.execute(
                self.http._request, "POST", "/fapi/v1/marginType",
                params=params, signed=True, futures=True
            )
        except Exception as e:
            logger.exception("Error changing futures margin type")
            raise BinanceAPIError(f"Error changing margin type for {symbol}: {e}")

    async def set_position_mode(self, dual_side_position: bool) -> Dict[str, Any]:
        """POST /fapi/v1/positionSide/dual"""
        try:
            params = {"dualSidePosition": str(dual_side_position).lower()}
            return await self.circuit_breaker.execute(
                self.http._request, "POST", "/fapi/v1/positionSide/dual",
                params=params, signed=True, futures=True
            )
        except Exception as e:
            logger.exception("Error setting futures position mode")
            raise BinanceAPIError(f"Error setting futures position mode: {e}")

    async def get_position_mode(self) -> Dict[str, Any]:
        """GET /fapi/v1/positionSide/dual"""
        try:
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/fapi/v1/positionSide/dual",
                signed=True, futures=True
            )
        except Exception as e:
            logger.exception("Error getting futures position mode")
            raise BinanceAPIError(f"Error getting futures position mode: {e}")

    async def get_adl_quantile(self, symbol: Optional[str] = None) -> List[Dict[str, Any]]:
        """GET /fapi/v1/adlQuantile"""
        try:
            params = {"symbol": symbol.upper()} if symbol else {}
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/fapi/v1/adlQuantile",
                params=params, signed=True, futures=True
            )
        except Exception as e:
            logger.exception("Error getting ADL quantile")
            raise BinanceAPIError(f"Error getting ADL quantile: {e}")

    async def get_commission_rate(self, symbol: str) -> Dict[str, Any]:
        """GET /fapi/v1/commissionRate"""
        try:
            params = {"symbol": symbol.upper()}
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/fapi/v1/commissionRate",
                params=params, signed=True, futures=True
            )
        except Exception as e:
            logger.exception("Error getting commission rate")
            raise BinanceAPIError(f"Error getting commission rate for {symbol}: {e}")


# ==== binance_pr_margin.py ====

# utils/binance/binance_pr_margin.py
"""
MarginClient: Margin account & order endpoints (sapi margin).
Endpoints covered:
- /sapi/v1/margin/account
- /sapi/v1/margin/order
- /sapi/v1/margin/openOrders
- /sapi/v1/margin/allOrders
- /sapi/v1/margin/myTrades
- /sapi/v1/margin/loan
- /sapi/v1/margin/repay
- /sapi/v1/margin/interestHistory
- /sapi/v1/margin/maxBorrowable
- /sapi/v1/margin/maxTransferable
- /sapi/v1/margin/isolated/pairs
"""
from typing import Any, Dict, List, Optional, Union
import logging

from .binance_pr_base import BinancePrivateBase
from .binance_exceptions import BinanceAPIError

logger = logging.getLogger(__name__)

class MarginClient(BinancePrivateBase):
    """Margin trading operations."""

    # ----------------------
    # Account
    # ----------------------
    async def get_account_info(self) -> Dict[str, Any]:
        """GET /sapi/v1/margin/account
        Returns margin account details.
        """
        try:
            await self._require_keys()
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/margin/account", signed=True
            )
        except Exception as e:
            logger.exception("Error getting margin account info")
            raise BinanceAPIError(f"Error getting margin account info: {e}")

    # ----------------------
    # Orders
    # ----------------------
    async def create_order(
        self,
        symbol: str,
        side: str,
        type_: str,
        quantity: float,
        price: Optional[float] = None,
        **kwargs
    ) -> Dict[str, Any]:
        """POST /sapi/v1/margin/order
        Create a margin order.

        Args:
            symbol: Trading pair e.g. 'BTCUSDT'
            side: 'BUY' or 'SELL'
            type_: 'LIMIT', 'MARKET', etc.
            quantity: Order quantity
            price: Order price (for LIMIT orders)
            **kwargs: Additional Binance params (e.g., timeInForce)
        """
        side = side.upper()
        type_ = type_.upper()
        if side not in ["BUY", "SELL"]:
            raise ValueError("Invalid side, must be 'BUY' or 'SELL'")
        if quantity <= 0:
            raise ValueError("Quantity must be positive")
        if type_ == "LIMIT" and (price is None or price <= 0):
            raise ValueError("LIMIT orders require a positive price")

        params: Dict[str, Any] = {"symbol": symbol.upper(), "side": side, "type": type_, "quantity": quantity}
        if price is not None:
            params["price"] = price
        params.update(kwargs)

        try:
            return await self.circuit_breaker.execute(
                self.http._request, "POST", "/sapi/v1/margin/order", params=params, signed=True
            )
        except Exception as e:
            logger.exception(f"Error creating margin order for {symbol}")
            raise BinanceAPIError(f"Error creating margin order for {symbol}: {e}")

    async def get_open_orders(self, symbol: Optional[str] = None) -> List[Dict[str, Any]]:
        """GET /sapi/v1/margin/openOrders
        Returns all open margin orders.
        """
        params = {"symbol": symbol.upper()} if symbol else {}
        try:
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/margin/openOrders", params=params, signed=True
            )
        except Exception as e:
            logger.exception("Error getting margin open orders")
            raise BinanceAPIError(f"Error getting margin open orders: {e}")

    async def get_all_orders(self, symbol: str, **kwargs) -> List[Dict[str, Any]]:
        """GET /sapi/v1/margin/allOrders
        Returns all margin orders for a symbol.

        Args:
            symbol: Trading pair
            **kwargs: Optional Binance parameters (orderId, limit, etc.)
        """
        params: Dict[str, Any] = {"symbol": symbol.upper()}
        params.update(kwargs)
        try:
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/margin/allOrders", params=params, signed=True
            )
        except Exception as e:
            logger.exception(f"Error getting all margin orders for {symbol}")
            raise BinanceAPIError(f"Error getting all margin orders for {symbol}: {e}")

    async def get_my_trades(self, symbol: str, **kwargs) -> List[Dict[str, Any]]:
        """GET /sapi/v1/margin/myTrades
        Get margin trade history for a symbol.
        """
        params: Dict[str, Any] = {"symbol": symbol.upper()}
        params.update(kwargs)
        try:
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/margin/myTrades", params=params, signed=True
            )
        except Exception as e:
            logger.exception(f"Error getting margin trades for {symbol}")
            raise BinanceAPIError(f"Error getting margin trades for {symbol}: {e}")

    # ----------------------
    # Margin Loans
    # ----------------------
    async def borrow(self, asset: str, amount: float) -> Dict[str, Any]:
        """POST /sapi/v1/margin/loan
        Borrow margin asset.
        """
        if amount <= 0:
            raise ValueError("Amount must be positive")
        params = {"asset": asset.upper(), "amount": amount}
        try:
            return await self.circuit_breaker.execute(
                self.http._request, "POST", "/sapi/v1/margin/loan", params=params, signed=True
            )
        except Exception as e:
            logger.exception(f"Error borrowing {asset}")
            raise BinanceAPIError(f"Error borrowing {asset}: {e}")

    async def repay(self, asset: str, amount: float) -> Dict[str, Any]:
        """POST /sapi/v1/margin/repay
        Repay borrowed margin asset.
        """
        if amount <= 0:
            raise ValueError("Amount must be positive")
        params = {"asset": asset.upper(), "amount": amount}
        try:
            return await self.circuit_breaker.execute(
                self.http._request, "POST", "/sapi/v1/margin/repay", params=params, signed=True
            )
        except Exception as e:
            logger.exception(f"Error repaying {asset}")
            raise BinanceAPIError(f"Error repaying {asset}: {e}")

    # ----------------------
    # Interest History
    # ----------------------
    async def get_interest_history(self, **kwargs) -> List[Dict[str, Any]]:
        """GET /sapi/v1/margin/interestHistory
        Returns interest history.
        """
        try:
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/margin/interestHistory", params=kwargs, signed=True
            )
        except Exception as e:
            logger.exception("Error getting margin interest history")
            raise BinanceAPIError(f"Error getting margin interest history: {e}")

    # ----------------------
    # Max Borrow/Transferable
    # ----------------------
    async def get_max_borrowable(self, asset: str) -> Dict[str, Any]:
        """GET /sapi/v1/margin/maxBorrowable
        Returns maximum borrowable amount for an asset.
        """
        params = {"asset": asset.upper()}
        try:
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/margin/maxBorrowable", params=params, signed=True
            )
        except Exception as e:
            logger.exception(f"Error getting max borrowable for {asset}")
            raise BinanceAPIError(f"Error getting max borrowable for {asset}: {e}")

    async def get_max_transferable(self, asset: str) -> Dict[str, Any]:
        """GET /sapi/v1/margin/maxTransferable
        Returns maximum transferable amount for an asset.
        """
        params = {"asset": asset.upper()}
        try:
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/margin/maxTransferable", params=params, signed=True
            )
        except Exception as e:
            logger.exception(f"Error getting max transferable for {asset}")
            raise BinanceAPIError(f"Error getting max transferable for {asset}: {e}")

    # ----------------------
    # Isolated Margin Pairs
    # ----------------------
    async def get_isolated_pairs(self) -> List[Dict[str, Any]]:
        """GET /sapi/v1/margin/isolated/pairs
        Returns isolated margin trading pairs.
        """
        try:
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/margin/isolated/pairs", signed=True
            )
        except Exception as e:
            logger.exception("Error getting isolated margin pairs")
            raise BinanceAPIError(f"Error getting isolated margin pairs: {e}")


# ==== binance_pr_mining.py ====

# utils/binance/binance_pr_mining.py
"""
MiningClient: Binance mining endpoints (sapi/v1/mining/*).
"""

from typing import Any, Dict, Optional
import logging

from .binance_pr_base import BinancePrivateBase
from .binance_exceptions import BinanceAPIError

logger = logging.getLogger(__name__)


class MiningClient(BinancePrivateBase):
    """Mining operations."""

    async def get_algo_list(self) -> Dict[str, Any]:
        """
        GET /sapi/v1/mining/pub/algoList
        Returns supported mining algorithms.
        """
        try:
            return await self.circuit_breaker.execute(
                self.http._request,
                "GET",
                "/sapi/v1/mining/pub/algoList",
                signed=False,
            )
        except BinanceAPIError:
            raise
        except Exception as e:
            logger.exception("Error fetching algo list")
            raise BinanceAPIError(f"Unexpected error in get_algo_list: {e}")

    async def get_coin_list(self) -> Dict[str, Any]:
        """
        GET /sapi/v1/mining/pub/coinList
        Returns supported mining coins.
        """
        try:
            return await self.circuit_breaker.execute(
                self.http._request,
                "GET",
                "/sapi/v1/mining/pub/coinList",
                signed=False,
            )
        except BinanceAPIError:
            raise
        except Exception as e:
            logger.exception("Error fetching coin list")
            raise BinanceAPIError(f"Unexpected error in get_coin_list: {e}")

    async def get_user_status(
        self, algo: str, user_name: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        GET /sapi/v1/mining/statistics/user/status
        Returns mining account status for given algo.
        Required:
            - algo: mining algorithm
        Optional:
            - userName: sub-account name
        """
        if not algo:
            raise ValueError("Parameter 'algo' is required")

        params: Dict[str, Any] = {"algo": algo}
        if user_name:
            params["userName"] = user_name

        try:
            return await self.circuit_breaker.execute(
                self.http._request,
                "GET",
                "/sapi/v1/mining/statistics/user/status",
                params=params,
                signed=True,
            )
        except BinanceAPIError:
            raise
        except Exception as e:
            logger.exception("Error fetching user status (params=%s)", params)
            raise BinanceAPIError(f"Unexpected error in get_user_status: {e}")

    async def get_earnings_list(
        self,
        algo: str,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        page_index: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> Dict[str, Any]:
        """
        GET /sapi/v1/mining/payment/list
        Returns payment records.
        """
        if not algo:
            raise ValueError("Parameter 'algo' is required")

        params: Dict[str, Any] = {"algo": algo}
        if start_time:
            params["startTime"] = start_time
        if end_time:
            params["endTime"] = end_time
        if page_index:
            params["pageIndex"] = page_index
        if page_size:
            params["pageSize"] = page_size

        try:
            return await self.circuit_breaker.execute(
                self.http._request,
                "GET",
                "/sapi/v1/mining/payment/list",
                params=params,
                signed=True,
            )
        except BinanceAPIError:
            raise
        except Exception as e:
            logger.exception("Error getting mining earnings list (params=%s)", params)
            raise BinanceAPIError(f"Unexpected error in get_earnings_list: {e}")

    async def get_worker_list(
        self,
        algo: str,
        user_name: Optional[str] = None,
        page_index: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> Dict[str, Any]:
        """
        GET /sapi/v1/mining/worker/list
        Returns workers list for given algo.
        """
        if not algo:
            raise ValueError("Parameter 'algo' is required")

        params: Dict[str, Any] = {"algo": algo}
        if user_name:
            params["userName"] = user_name
        if page_index:
            params["pageIndex"] = page_index
        if page_size:
            params["pageSize"] = page_size

        try:
            return await self.circuit_breaker.execute(
                self.http._request,
                "GET",
                "/sapi/v1/mining/worker/list",
                params=params,
                signed=True,
            )
        except BinanceAPIError:
            raise
        except Exception as e:
            logger.exception("Error getting worker list (params=%s)", params)
            raise BinanceAPIError(f"Unexpected error in get_worker_list: {e}")


# ==== binance_pr_savings.py ====

# utils/binance/binance_pr_savings.py
"""
SavingsClient: daily/flexible/locked savings endpoints.
Savings / Lending endpoints (flexible/locked/customizedFixed) (/sapi/v1/lending/*).
Enhanced with detailed HTTP & Binance error handling.
Includes unified abstraction for all product listings.
"""
from typing import Any, Dict, List, Optional
import logging

from .binance_pr_base import BinancePrivateBase
from .binance_exceptions import BinanceAPIError

logger = logging.getLogger(__name__)


class BinanceHTTPError(BinanceAPIError):
    """HTTP-level errors with status code."""
    def __init__(self, status_code: int, message: str, code: Optional[int] = None):
        super().__init__(f"HTTP {status_code}: {message} (Binance code: {code})")
        self.status_code = status_code
        self.code = code


class SavingsClient(BinancePrivateBase):
    """Savings / Lending operations (Daily, Flexible & Locked / Customized Fixed)."""

    VALID_PRODUCT_TYPES = ["ACTIVITY", "FLEXIBLE", "CUSTOMIZED_FIXED"]

    # -------------------- Daily / Flexible / Locked Unified --------------------
    async def get_all_products(
        self, product_type: str = "ACTIVITY", asset: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """
        Unified method to get all lending products.
        product_type: "ACTIVITY" | "FLEXIBLE" | "CUSTOMIZED_FIXED"
        """
        if product_type not in self.VALID_PRODUCT_TYPES:
            raise ValueError(f"Invalid product_type: {product_type}")

        try:
            params: Dict[str, Any] = {"type": product_type} if product_type != "CUSTOMIZED_FIXED" else {}
            if asset:
                params["asset"] = asset.upper()

            if product_type == "ACTIVITY":
                endpoint = "/sapi/v1/lending/daily/product/list"
            elif product_type == "FLEXIBLE":
                endpoint = "/sapi/v1/lending/flexible/product/list"
            else:  # CUSTOMIZED_FIXED
                endpoint = "/sapi/v1/lending/customizedFixed/product/list"

            resp = await self.circuit_breaker.execute(
                self.http._request, "GET", endpoint, params=params, signed=True
            )
            return resp

        except BinanceAPIError as e:
            logger.exception(f"Binance API error getting {product_type} product list: {e}")
            raise
        except Exception as e:
            logger.exception(f"Unexpected error getting {product_type} product list")
            status = getattr(e, "status_code", None)
            code = getattr(e, "code", None)
            raise BinanceHTTPError(status or 0, str(e), code)

    # -------------------- Daily / Flexible / Locked Purchase --------------------
    async def purchase_product(
        self, product_id: str, amount: float, product_type: str = "ACTIVITY"
    ) -> Dict[str, Any]:
        """
        Unified method to purchase a product.
        product_type: "ACTIVITY" | "FLEXIBLE" | "CUSTOMIZED_FIXED"
        """
        if product_type not in self.VALID_PRODUCT_TYPES:
            raise ValueError(f"Invalid product_type: {product_type}")
        if amount <= 0:
            raise ValueError("Amount must be positive")

        try:
            params = {"productId": product_id, "amount": amount}
            if product_type == "ACTIVITY":
                endpoint = "/sapi/v1/lending/daily/purchase"
            elif product_type == "FLEXIBLE":
                endpoint = "/sapi/v1/lending/flexible/purchase"
            else:  # CUSTOMIZED_FIXED
                endpoint = "/sapi/v1/lending/customizedFixed/purchase"

            resp = await self.circuit_breaker.execute(
                self.http._request, "POST", endpoint, params=params, signed=True
            )
            return resp

        except BinanceAPIError as e:
            logger.exception(f"Binance API error purchasing {product_type} product: {e}")
            raise
        except Exception as e:
            logger.exception(f"Unexpected error purchasing {product_type} product")
            status = getattr(e, "status_code", None)
            code = getattr(e, "code", None)
            raise BinanceHTTPError(status or 0, str(e), code)

    # -------------------- Daily / Flexible Balance --------------------
    async def get_balance(self, asset: Optional[str] = None) -> List[Dict[str, Any]]:
        try:
            params: Dict[str, Any] = {"asset": asset.upper()} if asset else {}
            endpoint = "/sapi/v1/lending/daily/token/position"
            resp = await self.circuit_breaker.execute(
                self.http._request, "GET", endpoint, params=params, signed=True
            )
            return resp
        except BinanceAPIError as e:
            logger.exception(f"Binance API error getting balance: {e}")
            raise
        except Exception as e:
            logger.exception("Unexpected error getting savings balance")
            status = getattr(e, "status_code", None)
            code = getattr(e, "code", None)
            raise BinanceHTTPError(status or 0, str(e), code)

    # -------------------- Locked / Customized Fixed Positions --------------------
    async def get_locked_positions(
        self, asset: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """GET /sapi/v1/lending/customizedFixed/position/list"""
        try:
            params: Dict[str, Any] = {"asset": asset.upper()} if asset else {}
            resp = await self.circuit_breaker.execute(
                self.http._request, "GET",
                "/sapi/v1/lending/customizedFixed/position/list",
                params=params, signed=True
            )
            return resp
        except BinanceAPIError as e:
            logger.exception(f"Binance API error getting locked positions: {e}")
            raise
        except Exception as e:
            logger.exception("Unexpected error getting locked positions")
            status = getattr(e, "status_code", None)
            code = getattr(e, "code", None)
            raise BinanceHTTPError(status or 0, str(e), code)


# ==== binance_pr_spot.py ====

# utils/binance/binance_pr_spot.py
"""
SpotClient: Spot account, order, market data, and OCO endpoints (signed).
Endpoints mirror Binance API v3 (/api/v3/*).
"""
from typing import Any, Dict, List, Optional
import logging

from .binance_pr_base import BinancePrivateBase
from .binance_exceptions import BinanceAPIError

logger = logging.getLogger(__name__)


class SpotClient(BinancePrivateBase):
    """Spot account & order operations."""

    # ------------------------- ACCOUNT -------------------------
    async def get_account_info(self) -> Dict[str, Any]:
        """GET /api/v3/account"""
        try:
            await self._require_keys()
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/api/v3/account", signed=True
            )
        except Exception as e:
            logger.exception("Error getting spot account info")
            raise BinanceAPIError(f"Error getting spot account info: {e}")

    async def get_account_balance(self, asset: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """Return full account info or specific asset balance."""
        try:
            info = await self.get_account_info()
            if asset:
                asset = asset.upper()
                for balance in info.get("balances", []):
                    if balance.get("asset") == asset:
                        return balance
                return None
            return info
        except Exception as e:
            logger.exception("Error getting spot account balance")
            raise BinanceAPIError(f"Error getting spot account balance: {e}")

    # ------------------------- ORDERS -------------------------
    async def place_order(
        self,
        symbol: str,
        side: str,
        type_: str,
        quantity: float,
        price: Optional[float] = None,
        time_in_force: Optional[str] = None,
        stop_price: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> Dict[str, Any]:
        """POST /api/v3/order"""
        try:
            await self._require_keys()
            symbol = symbol.upper()
            side = side.upper()
            type_ = type_.upper()

            params: Dict[str, Any] = {
                "symbol": symbol,
                "side": side,
                "type": type_,
                "quantity": quantity,
            }
            if price is not None:
                params["price"] = price
            if time_in_force:
                params["timeInForce"] = time_in_force
            if stop_price is not None:
                params["stopPrice"] = stop_price
            if new_client_order_id:
                params["newClientOrderId"] = new_client_order_id
            if recv_window:
                params["recvWindow"] = recv_window

            return await self.circuit_breaker.execute(
                self.http._request, "POST", "/api/v3/order", params=params, signed=True
            )
        except Exception as e:
            logger.exception(f"Error placing spot order for {symbol}")
            raise BinanceAPIError(f"Error placing spot order for {symbol}: {e}")

    async def cancel_order(
        self,
        symbol: str,
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> Dict[str, Any]:
        """DELETE /api/v3/order"""
        try:
            await self._require_keys()
            params = {"symbol": symbol.upper()}
            if order_id:
                params["orderId"] = order_id
            if orig_client_order_id:
                params["origClientOrderId"] = orig_client_order_id
            if recv_window:
                params["recvWindow"] = recv_window

            return await self.circuit_breaker.execute(
                self.http._request, "DELETE", "/api/v3/order", params=params, signed=True
            )
        except Exception as e:
            logger.exception(f"Error canceling spot order for {symbol}")
            raise BinanceAPIError(f"Error canceling spot order for {symbol}: {e}")

    async def get_open_orders(
        self, symbol: Optional[str] = None, recv_window: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """GET /api/v3/openOrders"""
        try:
            params = {"symbol": symbol.upper()} if symbol else {}
            if recv_window:
                params["recvWindow"] = recv_window
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/api/v3/openOrders", params=params, signed=True
            )
        except Exception as e:
            logger.exception("Error getting open spot orders")
            raise BinanceAPIError(f"Error getting open spot orders: {e}")

    async def get_order_history(
        self, symbol: str, limit: int = 50, recv_window: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """GET /api/v3/allOrders"""
        try:
            params = {"symbol": symbol.upper(), "limit": limit}
            if recv_window:
                params["recvWindow"] = recv_window
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/api/v3/allOrders", params=params, signed=True
            )
        except Exception as e:
            logger.exception(f"Error getting spot order history for {symbol}")
            raise BinanceAPIError(f"Error getting spot order history for {symbol}: {e}")

    async def get_my_trades(
        self, symbol: str, limit: int = 50, recv_window: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """GET /api/v3/myTrades"""
        try:
            params = {"symbol": symbol.upper(), "limit": limit}
            if recv_window:
                params["recvWindow"] = recv_window
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/api/v3/myTrades", params=params, signed=True
            )
        except Exception as e:
            logger.exception(f"Error getting trades for {symbol}")
            raise BinanceAPIError(f"Error getting trades for {symbol}: {e}")

    # ------------------------- OCO ORDERS -------------------------
    async def place_oco_order(
        self,
        symbol: str,
        side: str,
        quantity: float,
        price: float,
        stop_price: float,
        stop_limit_price: Optional[float] = None,
        list_client_order_id: Optional[str] = None,
        limit_client_order_id: Optional[str] = None,
        stop_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> Dict[str, Any]:
        """POST /api/v3/order/oco"""
        try:
            await self._require_keys()
            params = {
                "symbol": symbol.upper(),
                "side": side.upper(),
                "quantity": quantity,
                "price": price,
                "stopPrice": stop_price,
            }
            if stop_limit_price:
                params["stopLimitPrice"] = stop_limit_price
            if list_client_order_id:
                params["listClientOrderId"] = list_client_order_id
            if limit_client_order_id:
                params["limitClientOrderId"] = limit_client_order_id
            if stop_client_order_id:
                params["stopClientOrderId"] = stop_client_order_id
            if recv_window:
                params["recvWindow"] = recv_window

            return await self.circuit_breaker.execute(
                self.http._request, "POST", "/api/v3/order/oco", params=params, signed=True
            )
        except Exception as e:
            logger.exception(f"Error placing OCO order for {symbol}")
            raise BinanceAPIError(f"Error placing OCO order for {symbol}: {e}")

    # ------------------------- MARKET DATA -------------------------
    async def get_exchange_info(self) -> Dict[str, Any]:
        """GET /api/v3/exchangeInfo"""
        try:
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/api/v3/exchangeInfo"
            )
        except Exception as e:
            logger.exception("Error getting exchange info")
            raise BinanceAPIError(f"Error getting exchange info: {e}")

    async def get_symbol_price(self, symbol: str) -> Dict[str, Any]:
        """GET /api/v3/ticker/price"""
        try:
            params = {"symbol": symbol.upper()}
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/api/v3/ticker/price", params=params
            )
        except Exception as e:
            logger.exception(f"Error getting price for {symbol}")
            raise BinanceAPIError(f"Error getting price for {symbol}: {e}")

    async def get_book_ticker(self, symbol: Optional[str] = None) -> Dict[str, Any]:
        """GET /api/v3/ticker/bookTicker"""
        try:
            params = {"symbol": symbol.upper()} if symbol else {}
            return await self.circuit_breaker.execute(
                self.http._request, "GET", "/api/v3/ticker/bookTicker", params=params
            )
        except Exception as e:
            logger.exception(f"Error getting book ticker for {symbol}")
            raise BinanceAPIError(f"Error getting book ticker for {symbol}: {e}")


# ==== binance_pr_staking.py ====

# utils/binance/binance_pr_staking.py
"""
StakingClient: staking endpoints (sapi staking).

Geliştirmeler:
- Parametre validasyonu (amount, start/endTime, txn_type)
- Async typing ve return tipleri
- Detaylı error handling: HTTP code, Binance errorCode parse
- Rate-limit ve retry-aware
- Opsiyonel endpointler: interestHistory, projectList
"""
from typing import Any, Dict, List, Optional
import logging
import asyncio

from .binance_pr_base import BinancePrivateBase
#from .binance_exceptions import BinanceAPIError, BinanceRequestError, BinanceRateLimitError, BinanceAuthError, BinanceValidationError
from .binance_exceptions import BinanceAPIError, BinanceRequestError, BinanceRateLimitError, BinanceAuthenticationError  # BinanceValidationError yoksa çıkar

logger = logging.getLogger(__name__)


class StakingClient(BinancePrivateBase):
    """Staking operations."""

    VALID_TXN_TYPES = {"SUBSCRIPTION", "REDEMPTION", "HOLD"}

    async def _request(self, method: str, endpoint: str, params: Dict[str, Any], signed: bool, retries: int = 3) -> Any:
        """
        Wrapper to handle HTTP request with:
        - Detailed error parsing
        - Rate limit handling (429)
        - Retry logic
        """
        for attempt in range(retries):
            try:
                return await self.circuit_breaker.execute(
                    self.http._request, method, endpoint, params=params, signed=signed
                )
            except BinanceRequestError as e:
                error_code = getattr(e, "error_code", None)
                error_msg = getattr(e, "message", str(e))
                status_code = getattr(e, "status_code", None)

                logger.error(
                    "BinanceRequestError: status=%s, code=%s, msg=%s, endpoint=%s, params=%s",
                    status_code, error_code, error_msg, endpoint, params
                )

                # Rate limit
                if status_code == 429 or error_code == -1003:
                    logger.warning("Rate limit hit, retrying in 1s... attempt %d/%d", attempt+1, retries)
                    await asyncio.sleep(1)
                    continue
                # IP ban / forbidden
                if status_code == 418:
                    raise BinanceRateLimitError("IP banned temporarily") from e
                # Auth error
                if status_code in (401, 403):
                    raise BinanceAuthError(f"Authentication error: {error_msg}") from e
                # Validation error
                if status_code == 400:
                    raise BinanceValidationError(f"Validation error: {error_msg}") from e

                raise BinanceAPIError(f"Binance API error: status={status_code}, code={error_code}, msg={error_msg}") from e
            except Exception as e:
                logger.exception("Unexpected error on endpoint=%s, params=%s", endpoint, params)
                raise BinanceAPIError(f"Unexpected error: {e}") from e
        raise BinanceRateLimitError("Max retries reached due to rate limiting")

    # ----------------------------
    # Staking endpoints
    # ----------------------------
    async def get_product_list(self, product: str = "STAKING", asset: Optional[str] = None) -> List[Dict[str, Any]]:
        if not product:
            raise ValueError("product is required")
        params: Dict[str, Any] = {"product": product}
        if asset:
            params["asset"] = asset.upper()
        return await self._request("GET", "/sapi/v1/staking/productList", params, signed=True)

    async def stake_asset(self, product: str, product_id: str, amount: float) -> Dict[str, Any]:
        if not product or not product_id:
            raise ValueError("product and product_id are required")
        if amount <= 0:
            raise ValueError("amount must be positive")
        params = {"product": product, "productId": product_id, "amount": amount}
        return await self._request("POST", "/sapi/v1/staking/purchase", params, signed=True)

    async def unstake_asset(
        self,
        product: str,
        product_id: str,
        position_id: Optional[str] = None,
        amount: Optional[float] = None
    ) -> Dict[str, Any]:
        if not product or not product_id:
            raise ValueError("product and product_id are required")
        if amount is not None and amount <= 0:
            raise ValueError("amount must be positive if provided")
        params: Dict[str, Any] = {"product": product, "productId": product_id}
        if position_id:
            params["positionId"] = position_id
        if amount is not None:
            params["amount"] = amount
        return await self._request("POST", "/sapi/v1/staking/redeem", params, signed=True)

    async def get_history(
        self,
        product: str,
        txn_type: str,
        asset: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        if not product:
            raise ValueError("product is required")
        if txn_type not in self.VALID_TXN_TYPES:
            raise ValueError(f"txn_type must be one of {self.VALID_TXN_TYPES}")
        if start_time and end_time and start_time > end_time:
            raise ValueError("start_time cannot be greater than end_time")

        params: Dict[str, Any] = {"product": product, "txnType": txn_type}
        if asset:
            params["asset"] = asset.upper()
        if start_time:
            params["startTime"] = start_time
        if end_time:
            params["endTime"] = end_time
        return await self._request("GET", "/sapi/v1/staking/stakingRecord", params, signed=True)

    # ----------------------------
    # Optional / advanced endpoints
    # ----------------------------
    async def get_interest_history(
        self,
        product: str,
        asset: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """Get staking interest history."""
        if not product:
            raise ValueError("product is required")
        if start_time and end_time and start_time > end_time:
            raise ValueError("start_time cannot be greater than end_time")
        params: Dict[str, Any] = {"product": product}
        if asset:
            params["asset"] = asset.upper()
        if start_time:
            params["startTime"] = start_time
        if end_time:
            params["endTime"] = end_time
        return await self._request("GET", "/sapi/v1/staking/interestHistory", params, signed=True)

    async def get_project_list(self, product: str = "STAKING") -> List[Dict[str, Any]]:
        """Get list of staking projects."""
        if not product:
            raise ValueError("product is required")
        params: Dict[str, Any] = {"product": product}
        return await self._request("GET", "/sapi/v1/staking/projectList", params, signed=True)


# ==== binance_pr_subaccount.py ====

# utils/binance/binance_pr_subaccount.py
"""
SubAccountClient: sub-account management endpoints.
Sub-account endpoints (/sapi/v1/sub-account/*).
Includes list, create, assets, transfer, futures, margin, status operations.
"""
from typing import Any, Dict, List, Optional
import logging
import re

from .binance_pr_base import BinancePrivateBase
#from .binance_exceptions import BinanceAPIError, BinanceRequestException, BinanceRateLimitException
from .binance_exceptions import BinanceAPIError, BinanceRequestError, BinanceRateLimitError # BinanceValidationError yoksa çıkar

logger = logging.getLogger(__name__)

EMAIL_REGEX = r"[^@]+@[^@]+\.[^@]+"

class SubAccountClient(BinancePrivateBase):
    """Sub-account operations."""

    async def get_list(self, email: Optional[str] = None) -> List[Dict[str, Any]]:
        """GET /sapi/v1/sub-account/list"""
        if email and not re.match(EMAIL_REGEX, email):
            raise ValueError(f"Invalid email format: {email}")
        params = {"email": email} if email else {}
        try:
            resp = await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/sub-account/list", params=params, signed=True
            )
            self._handle_api_error(resp)
            return resp.get("subAccounts", [])
        except Exception as e:
            logger.exception("Error getting sub-account list")
            raise BinanceAPIError(f"Error getting sub-account list: {e}")

    async def create(self, sub_account_string: str) -> Dict[str, Any]:
        """POST /sapi/v1/sub-account/virtualSubAccount"""
        if not sub_account_string or not isinstance(sub_account_string, str):
            raise ValueError("sub_account_string must be a non-empty string")
        params = {"subAccountString": sub_account_string}
        try:
            resp = await self.circuit_breaker.execute(
                self.http._request, "POST", "/sapi/v1/sub-account/virtualSubAccount", params=params, signed=True
            )
            self._handle_api_error(resp)
            return resp
        except Exception as e:
            logger.exception("Error creating sub-account")
            raise BinanceAPIError(f"Error creating sub-account: {e}")

    async def get_assets(self, email: str) -> Dict[str, Any]:
        """GET /sapi/v3/sub-account/assets"""
        if not re.match(EMAIL_REGEX, email):
            raise ValueError(f"Invalid email format: {email}")
        params = {"email": email}
        try:
            resp = await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v3/sub-account/assets", params=params, signed=True
            )
            self._handle_api_error(resp)
            return resp
        except Exception as e:
            logger.exception("Error getting sub-account assets")
            raise BinanceAPIError(f"Error getting sub-account assets: {e}")

    async def transfer(self, from_email: str, to_email: str, asset: str, amount: float) -> Dict[str, Any]:
        """POST /sapi/v1/sub-account/transfer"""
        for email in (from_email, to_email):
            if not re.match(EMAIL_REGEX, email):
                raise ValueError(f"Invalid email format: {email}")
        if not asset:
            raise ValueError("asset must be a non-empty string")
        if amount <= 0:
            raise ValueError("amount must be positive")
        params = {"fromEmail": from_email, "toEmail": to_email, "asset": asset, "amount": amount}
        try:
            resp = await self.circuit_breaker.execute(
                self.http._request, "POST", "/sapi/v1/sub-account/transfer", params=params, signed=True
            )
            self._handle_api_error(resp)
            return resp
        except Exception as e:
            logger.exception("Error transferring between sub-accounts")
            raise BinanceAPIError(f"Error transferring between sub-accounts: {e}")

    async def get_futures_account(self, email: str) -> Dict[str, Any]:
        """GET /sapi/v1/sub-account/futures/account"""
        if not re.match(EMAIL_REGEX, email):
            raise ValueError(f"Invalid email format: {email}")
        params = {"email": email}
        try:
            resp = await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/sub-account/futures/account", params=params, signed=True
            )
            self._handle_api_error(resp)
            return resp
        except Exception as e:
            logger.exception("Error getting sub-account futures account")
            raise BinanceAPIError(f"Error getting sub-account futures account: {e}")

    async def get_margin_account(self, email: str) -> Dict[str, Any]:
        """GET /sapi/v1/sub-account/margin/account"""
        if not re.match(EMAIL_REGEX, email):
            raise ValueError(f"Invalid email format: {email}")
        params = {"email": email}
        try:
            resp = await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/sub-account/margin/account", params=params, signed=True
            )
            self._handle_api_error(resp)
            return resp
        except Exception as e:
            logger.exception("Error getting sub-account margin account")
            raise BinanceAPIError(f"Error getting sub-account margin account: {e}")

    async def get_status(self, email: str) -> Dict[str, Any]:
        """GET /sapi/v1/sub-account/status"""
        if not re.match(EMAIL_REGEX, email):
            raise ValueError(f"Invalid email format: {email}")
        params = {"email": email}
        try:
            resp = await self.circuit_breaker.execute(
                self.http._request, "GET", "/sapi/v1/sub-account/status", params=params, signed=True
            )
            self._handle_api_error(resp)
            return resp
        except Exception as e:
            logger.exception("Error getting sub-account status")
            raise BinanceAPIError(f"Error getting sub-account status: {e}")

    def _handle_api_error(self, resp: Dict[str, Any]) -> None:
        """Parse Binance API errors and raise exceptions."""
        if not resp:
            raise BinanceRequestException("Empty response from Binance API")
        code = resp.get("code")
        msg = resp.get("msg")
        if code:
            if code in [418, 429]:
                raise BinanceRateLimitException(f"Rate limit hit: {code} - {msg}")
            raise BinanceRequestException(f"Binance API error {code}: {msg}")


# ==== binance_pr_userstream.py ====

# utils/binance/binance_pr_userstream.py
"""
UserStreamClient: user data stream endpoints (listenKey).
Supports Spot (/api/v3/userDataStream), Futures (/fapi/v1/listenKey), and Margin (/sapi/v1/userDataStream)
"""
from typing import Any, Dict, TypedDict
import logging

from .binance_pr_base import BinancePrivateBase
from .binance_exceptions import BinanceAPIError

logger = logging.getLogger(__name__)


class ListenKeyResponse(TypedDict):
    listenKey: str


class UserStreamClient(BinancePrivateBase):
    """Create, keepalive, and close listen keys for Spot, Futures, and Margin accounts."""

    async def create_listen_key(self, futures: bool = False, margin: bool = False) -> ListenKeyResponse:
        """
        POST user data stream.
        - Spot: /api/v3/userDataStream
        - Futures: /fapi/v1/listenKey
        - Margin: /sapi/v1/userDataStream
        """
        if futures and margin:
            raise ValueError("Cannot set both futures and margin to True")
        try:
            if futures:
                endpoint = "/fapi/v1/listenKey"
            elif margin:
                endpoint = "/sapi/v1/userDataStream"
            else:
                endpoint = "/api/v3/userDataStream"

            resp = await self.circuit_breaker.execute(
                self.http._request,
                "POST",
                endpoint,
                signed=True,
                futures=futures,
                margin=margin,
            )

            if "listenKey" not in resp:
                raise BinanceAPIError(f"No listenKey returned from Binance: {resp}")

            return ListenKeyResponse(listenKey=resp["listenKey"])
        except Exception as e:
            logger.exception("Error creating listen key")
            raise BinanceAPIError(f"Error creating listen key: {e}")

    async def keepalive_listen_key(self, listen_key: str, futures: bool = False, margin: bool = False) -> Dict[str, Any]:
        """
        PUT user data stream to keep alive.
        """
        if not listen_key or not isinstance(listen_key, str):
            raise ValueError("listen_key must be a non-empty string")
        if futures and margin:
            raise ValueError("Cannot set both futures and margin to True")
        try:
            if futures:
                endpoint = "/fapi/v1/listenKey"
            elif margin:
                endpoint = "/sapi/v1/userDataStream"
            else:
                endpoint = "/api/v3/userDataStream"

            params = {"listenKey": listen_key}

            return await self.circuit_breaker.execute(
                self.http._request,
                "PUT",
                endpoint,
                params=params,
                signed=True,
                futures=futures,
                margin=margin,
            )
        except Exception as e:
            logger.exception("Error keeping listen key alive")
            raise BinanceAPIError(f"Error keeping listen key alive: {e}")

    async def close_listen_key(self, listen_key: str, futures: bool = False, margin: bool = False) -> Dict[str, Any]:
        """
        DELETE user data stream.
        """
        if not listen_key or not isinstance(listen_key, str):
            raise ValueError("listen_key must be a non-empty string")
        if futures and margin:
            raise ValueError("Cannot set both futures and margin to True")
        try:
            if futures:
                endpoint = "/fapi/v1/listenKey"
            elif margin:
                endpoint = "/sapi/v1/userDataStream"
            else:
                endpoint = "/api/v3/userDataStream"

            params = {"listenKey": listen_key}

            return await self.circuit_breaker.execute(
                self.http._request,
                "DELETE",
                endpoint,
                params=params,
                signed=True,
                futures=futures,
                margin=margin,
            )
        except Exception as e:
            logger.exception("Error closing listen key")
            raise BinanceAPIError(f"Error closing listen key: {e}")


